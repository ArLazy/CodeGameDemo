<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Collector - Screeps-like Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: #4ecca3;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(78, 204, 163, 0.5);
        }

        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #gameCanvas {
            border: 3px solid #4ecca3;
            border-radius: 8px;
            background: #0f0f1a;
            box-shadow: 0 0 20px rgba(78, 204, 163, 0.3);
        }

        .info-panel {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #0f3460;
        }

        .info-panel h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
            flex-wrap: wrap;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-value {
            color: #4ecca3;
            font-weight: bold;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 400px;
        }

        .console-section {
            background: #16213e;
            border-radius: 8px;
            border: 2px solid #0f3460;
            overflow: hidden;
        }

        .console-header {
            background: #0f3460;
            padding: 10px 15px;
            font-weight: bold;
            color: #4ecca3;
        }

        #commandInput {
            width: 100%;
            height: 200px;
            background: #0a0a14;
            color: #4ecca3;
            border: none;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
        }

        #commandInput::placeholder {
            color: #555;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-generate {
            background: #e94560;
            color: white;
        }

        .btn-generate:hover {
            background: #ff6b6b;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .btn-run {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .btn-run:hover {
            background: #6effc0;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78, 204, 163, 0.4);
        }

        .btn-restart {
            background: #f39c12;
            color: #1a1a2e;
        }

        .btn-restart:hover {
            background: #f5b041;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .btn-clear {
            background: #533483;
            color: white;
        }

        .btn-clear:hover {
            background: #7b5ab7;
            transform: translateY(-2px);
        }

        .instructions {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #0f3460;
            font-size: 13px;
            line-height: 1.6;
        }

        .instructions h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .instructions code {
            background: #0a0a14;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4ecca3;
        }

        .instructions ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .status-message {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            font-weight: bold;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-waiting {
            background: #533483;
            color: #fff;
        }

        .status-running {
            background: #f39c12;
            color: #fff;
        }

        .status-success {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .status-failed {
            background: #e94560;
            color: #fff;
        }

        .status-dead {
            background: #8b0000;
            color: #fff;
        }

        .command-history {
            background: #0a0a14;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
        }

        .command-line {
            padding: 3px 0;
            border-bottom: 1px solid #1a1a2e;
        }

        .command-success {
            color: #4ecca3;
        }

        .command-error {
            color: #e94560;
        }

        .command-info {
            color: #f39c12;
        }

        .command-dead {
            color: #ff4444;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>CODE COLLECTOR</h1>
    
    <div class="game-container">
        <div class="left-panel">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            
            <div class="info-panel">
                <h3>Game Status</h3>
                <div class="stats">
                    <div class="stat">
                        <span>Resources:</span>
                        <span class="stat-value" id="resourceCount">0/0</span>
                    </div>
                    <div class="stat">
                        <span>Steps:</span>
                        <span class="stat-value" id="stepCount">0</span>
                    </div>
                    <div class="stat">
                        <span>Pos:</span>
                        <span class="stat-value" id="playerPos">0,0</span>
                    </div>
                    <div class="stat">
                        <span>Health:</span>
                        <span class="stat-value" id="healthStatus">OK</span>
                    </div>
                </div>
            </div>
            
            <div id="statusMessage" class="status-message status-waiting">
                Press "Generate Task" to start
            </div>
        </div>
        
        <div class="right-panel">
            <div class="console-section">
                <div class="console-header">Command Console</div>
                <textarea id="commandInput" placeholder="Enter your commands here...

Example with coefficients:
right 3
down 2
collect
bye right
collect

The bye command moves until blocked."></textarea>
            </div>
            
            <div class="button-group">
                <button class="btn-generate" onclick="generateTask()">Generate Task</button>
                <button class="btn-restart" onclick="restartGame()">Restart</button>
                <button class="btn-run" onclick="runCommands()">Run Code</button>
                <button class="btn-clear" onclick="clearConsole()">Clear</button>
            </div>
            
            <div class="console-section">
                <div class="console-header">Execution Log</div>
                <div id="commandHistory" class="command-history">
                    <div class="command-line command-info">Ready to start...</div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>Available Commands</h3>
                <ul>
                    <li><code>up [n]</code> - Move up (n times, default 1)</li>
                    <li><code>down [n]</code> - Move down (n times, default 1)</li>
                    <li><code>left [n]</code> - Move left (n times, default 1)</li>
                    <li><code>right [n]</code> - Move right (n times, default 1)</li>
                    <li><code>bye [direction]</code> - Move in direction until blocked</li>
                    <li><code>collect</code> - Collect resource at current position</li>
                </ul>
                <p style="margin-top: 10px;">
                    <strong>Goal:</strong> Collect all resources (yellow). Avoid walls (gray) and <span style="color: #ff4444; font-weight: bold;">DANGER ZONES (red)</span> - touching them kills you! Your code runs in one iteration.
                </p>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 10;
        const CELL_SIZE = 40;
        
        const initialState = {
            grid: [],
            player: { x: 0, y: 0 },
            resources: [],
            walls: [],
            dangerZones: [],
            collected: 0,
            totalResources: 0,
            steps: 0,
            isRunning: false,
            gameEnded: false,
            playerDead: false,
            originalPlayer: { x: 0, y: 0 },
            originalResources: [],
            originalGrid: []
        };

        let gameState = JSON.parse(JSON.stringify(initialState));

        // Initialize empty grid
        function initGrid() {
            gameState.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    gameState.grid[y][x] = 'empty';
                }
            }
        }

        // Generate random task
        function generateTask() {
            initGrid();
            
            // Reset game state
            gameState.player = { x: 0, y: 0 };
            gameState.originalPlayer = { x: 0, y: 0 };
            gameState.resources = [];
            gameState.walls = [];
            gameState.dangerZones = [];
            gameState.collected = 0;
            gameState.totalResources = 0;
            gameState.steps = 0;
            gameState.isRunning = false;
            gameState.gameEnded = false;
            gameState.playerDead = false;
            
            // Generate walls (15-25 walls)
            const wallCount = Math.floor(Math.random() * 11) + 15;
            for (let i = 0; i < wallCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while ((x === 0 && y === 0) || gameState.grid[y][x] !== 'empty');
                
                gameState.grid[y][x] = 'wall';
                gameState.walls.push({ x, y });
            }
            
            // Generate danger zones (5-8 red cells)
            const dangerCount = Math.floor(Math.random() * 4) + 5;
            for (let i = 0; i < dangerCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while ((x === 0 && y === 0) || gameState.grid[y][x] !== 'empty');
                
                gameState.grid[y][x] = 'danger';
                gameState.dangerZones.push({ x, y });
            }
            
            // Generate resources (5-10 resources)
            const resourceCount = Math.floor(Math.random() * 6) + 5;
            for (let i = 0; i < resourceCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while ((x === 0 && y === 0) || gameState.grid[y][x] !== 'empty');
                
                gameState.grid[y][x] = 'resource';
                gameState.resources.push({ x, y, collected: false });
            }
            
            gameState.totalResources = resourceCount;
            
            // Store original state for restart
            saveOriginalState();
            
            // Clear history and update status
            clearHistory();
            addToHistory('New task generated!', 'info');
            updateStatus('Task ready - Write your code!', 'waiting');
            updateStats();
            draw();
        }

        // Save original state for restart
        function saveOriginalState() {
            gameState.originalPlayer = { ...gameState.player };
            gameState.originalResources = gameState.resources.map(r => ({ ...r }));
            gameState.originalGrid = gameState.grid.map(row => [...row]);
        }

        // Restart game with same layout
        function restartGame() {
            if (gameState.originalGrid.length === 0) {
                addToHistory('No task to restart. Generate a task first!', 'error');
                return;
            }
            
            // Restore original state
            gameState.player = { ...gameState.originalPlayer };
            gameState.resources = gameState.originalResources.map(r => ({ ...r }));
            gameState.grid = gameState.originalGrid.map(row => [...row]);
            gameState.collected = 0;
            gameState.steps = 0;
            gameState.isRunning = false;
            gameState.gameEnded = false;
            gameState.playerDead = false;
            
            clearHistory();
            addToHistory('Game restarted with same layout!', 'info');
            updateStatus('Task restarted - Write your code!', 'waiting');
            updateStats();
            draw();
        }

        // Draw the game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, GRID_SIZE * CELL_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(GRID_SIZE * CELL_SIZE, i * CELL_SIZE);
                ctx.stroke();
            }
            
            // Draw danger zones (red cells)
            gameState.dangerZones.forEach(danger => {
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(
                    danger.x * CELL_SIZE + 1,
                    danger.y * CELL_SIZE + 1,
                    CELL_SIZE - 2,
                    CELL_SIZE - 2
                );
                
                // Add hazard pattern
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(danger.x * CELL_SIZE + 5, danger.y * CELL_SIZE + 5);
                ctx.lineTo((danger.x + 1) * CELL_SIZE - 5, (danger.y + 1) * CELL_SIZE - 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo((danger.x + 1) * CELL_SIZE - 5, danger.y * CELL_SIZE + 5);
                ctx.lineTo(danger.x * CELL_SIZE + 5, (danger.y + 1) * CELL_SIZE - 5);
                ctx.stroke();
            });
            
            // Draw walls
            ctx.fillStyle = '#555';
            gameState.walls.forEach(wall => {
                ctx.fillRect(
                    wall.x * CELL_SIZE + 2,
                    wall.y * CELL_SIZE + 2,
                    CELL_SIZE - 4,
                    CELL_SIZE - 4
                );
            });
            
            // Draw resources
            gameState.resources.forEach(resource => {
                if (!resource.collected) {
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(
                        resource.x * CELL_SIZE + CELL_SIZE / 2,
                        resource.y * CELL_SIZE + CELL_SIZE / 2,
                        CELL_SIZE / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Glow effect
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw player
            if (!gameState.playerDead) {
                ctx.fillStyle = '#4ecca3';
                ctx.fillRect(
                    gameState.player.x * CELL_SIZE + 5,
                    gameState.player.y * CELL_SIZE + 5,
                    CELL_SIZE - 10,
                    CELL_SIZE - 10
                );
                
                // Player glow
                ctx.shadowColor = '#4ecca3';
                ctx.shadowBlur = 15;
                ctx.fillRect(
                    gameState.player.x * CELL_SIZE + 5,
                    gameState.player.y * CELL_SIZE + 5,
                    CELL_SIZE - 10,
                    CELL_SIZE - 10
                );
                ctx.shadowBlur = 0;
            }
        }

        // Execute commands
        async function runCommands() {
            if (gameState.isRunning) {
                return;
            }
            
            if (gameState.gameEnded) {
                addToHistory('Game ended. Restart or generate new task to play again.', 'error');
                return;
            }
            
            const input = document.getElementById('commandInput').value.trim();
            if (!input) {
                addToHistory('Please enter commands first!', 'error');
                return;
            }
            
            gameState.isRunning = true;
            updateStatus('Running code...', 'running');
            clearHistory();
            addToHistory('Starting execution...', 'info');
            
            const lines = input.split('\n').map(line => line.trim()).filter(line => line);
            
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                const parts = line.split(/\s+/);
                const command = parts[0].toLowerCase();
                
                addToHistory(`> ${line}`, 'info');
                
                let result;
                
                if (command === 'bye') {
                    // bye command - move until blocked
                    const direction = parts[1] ? parts[1].toLowerCase() : null;
                    if (!direction || !['up', 'down', 'left', 'right'].includes(direction)) {
                        result = { success: false, message: 'bye command requires a valid direction (up/down/left/right)' };
                    } else {
                        result = await executeByeCommand(direction);
                    }
                } else if (['up', 'down', 'left', 'right'].includes(command)) {
                    // Movement command with optional coefficient
                    const coefficient = parts[1] ? parseInt(parts[1]) : 1;
                    if (isNaN(coefficient) || coefficient < 1) {
                        result = { success: false, message: `Invalid coefficient: "${parts[1]}"` };
                    } else {
                        result = await executeMovementCommand(command, coefficient);
                    }
                } else if (command === 'collect') {
                    result = collectResource();
                } else {
                    result = { success: false, message: `Unknown command: "${command}"` };
                }
                
                if (result.success) {
                    addToHistory(result.message, 'success');
                } else {
                    addToHistory(result.message, result.dead ? 'dead' : 'error');
                    if (result.dead) {
                        gameState.playerDead = true;
                        gameState.gameEnded = true;
                        draw();
                        updateStatus('GAME OVER - You died!', 'dead');
                        gameState.isRunning = false;
                        return;
                    }
                    break;
                }
                
                // Check win condition
                if (gameState.collected === gameState.totalResources) {
                    updateStatus(`SUCCESS! All resources collected in ${gameState.steps} steps!`, 'success');
                    addToHistory('ðŸŽ‰ All resources collected!', 'success');
                    gameState.gameEnded = true;
                    gameState.isRunning = false;
                    return;
                }
                
                // Small delay for visualization
                await sleep(200);
            }
            
            gameState.isRunning = false;
            
            if (!gameState.gameEnded) {
                if (gameState.collected < gameState.totalResources) {
                    updateStatus('Code execution complete. Resources remain!', 'failed');
                    addToHistory('Execution complete. Not all resources collected.', 'error');
                    gameState.gameEnded = true;
                }
            }
        }

        // Execute bye command (move until blocked)
        async function executeByeCommand(direction) {
            let dx = 0, dy = 0;
            switch (direction) {
                case 'up': dy = -1; break;
                case 'down': dy = 1; break;
                case 'left': dx = -1; break;
                case 'right': dx = 1; break;
            }
            
            let moveCount = 0;
            
            while (true) {
                const newX = gameState.player.x + dx;
                const newY = gameState.player.y + dy;
                
                // Check bounds
                if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                    break;
                }
                
                // Check walls
                if (gameState.grid[newY][newX] === 'wall') {
                    break;
                }
                
                // Check danger zones
                if (gameState.grid[newY][newX] === 'danger') {
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                    moveCount++;
                    gameState.steps++;
                    draw();
                    return { 
                        success: false, 
                        dead: true,
                        message: `Moved ${direction} ${moveCount} time(s) and entered a DANGER ZONE! ðŸ’€` 
                    };
                }
                
                // Move player
                gameState.player.x = newX;
                gameState.player.y = newY;
                moveCount++;
                gameState.steps++;
                
                draw();
                await sleep(150);
            }
            
            if (moveCount === 0) {
                return { success: false, message: `Cannot move ${direction}: Blocked immediately!` };
            }
            
            return { success: true, message: `Moved ${direction} ${moveCount} time(s) until blocked` };
        }

        // Execute movement command with coefficient
        async function executeMovementCommand(direction, coefficient) {
            let dx = 0, dy = 0;
            switch (direction) {
                case 'up': dy = -1; break;
                case 'down': dy = 1; break;
                case 'left': dx = -1; break;
                case 'right': dx = 1; break;
            }
            
            for (let i = 0; i < coefficient; i++) {
                const result = movePlayer(dx, dy);
                
                if (result.dead) {
                    return result;
                }
                
                if (!result.success) {
                    if (i === 0) {
                        return result;
                    } else {
                        return { success: true, message: `Moved ${direction} ${i} time(s), then blocked` };
                    }
                }
                
                draw();
                await sleep(150);
            }
            
            return { success: true, message: `Moved ${direction} ${coefficient} time(s)` };
        }

        // Move player
        function movePlayer(dx, dy) {
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;
            
            // Check bounds
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                return { success: false, message: 'Cannot move: Out of bounds!' };
            }
            
            // Check walls
            if (gameState.grid[newY][newX] === 'wall') {
                return { success: false, message: 'Cannot move: Wall in the way!' };
            }
            
            // Check danger zones
            if (gameState.grid[newY][newX] === 'danger') {
                gameState.player.x = newX;
                gameState.player.y = newY;
                return { 
                    success: false, 
                    dead: true,
                    message: 'You entered a DANGER ZONE and died! ðŸ’€' 
                };
            }
            
            gameState.player.x = newX;
            gameState.player.y = newY;
            
            const dir = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'down' : 'up';
            return { success: true, message: `Moved ${dir} to (${newX}, ${newY})` };
        }

        // Collect resource
        function collectResource() {
            const resource = gameState.resources.find(
                r => r.x === gameState.player.x && r.y === gameState.player.y && !r.collected
            );
            
            if (resource) {
                resource.collected = true;
                gameState.collected++;
                gameState.grid[resource.y][resource.x] = 'empty';
                return { success: true, message: `Collected resource at (${resource.x}, ${resource.y})!` };
            }
            
            return { success: false, message: 'No resource to collect at current position!' };
        }

        // Utility functions
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function updateStats() {
            document.getElementById('resourceCount').textContent = 
                `${gameState.collected}/${gameState.totalResources}`;
            document.getElementById('stepCount').textContent = gameState.steps;
            document.getElementById('playerPos').textContent = 
                `${gameState.player.x},${gameState.player.y}`;
            document.getElementById('healthStatus').textContent = 
                gameState.playerDead ? 'DEAD' : 'OK';
            document.getElementById('healthStatus').style.color = 
                gameState.playerDead ? '#ff4444' : '#4ecca3';
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
        }

        function addToHistory(message, type) {
            const historyEl = document.getElementById('commandHistory');
            const line = document.createElement('div');
            line.className = `command-line command-${type}`;
            line.textContent = message;
            historyEl.appendChild(line);
            historyEl.scrollTop = historyEl.scrollHeight;
        }

        function clearHistory() {
            document.getElementById('commandHistory').innerHTML = '';
        }

        function clearConsole() {
            document.getElementById('commandInput').value = '';
            clearHistory();
            addToHistory('Console cleared.', 'info');
        }

        // Initial draw
        initGrid();
        draw();
    </script>
</body>
</html>
