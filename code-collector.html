<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Collector - Screeps-like Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: #4ecca3;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(78, 204, 163, 0.5);
        }

        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #gameCanvas {
            border: 3px solid #4ecca3;
            border-radius: 8px;
            background: #0f0f1a;
            box-shadow: 0 0 20px rgba(78, 204, 163, 0.3);
        }

        .info-panel {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #0f3460;
        }

        .info-panel h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 14px;
            flex-wrap: wrap;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-value {
            color: #4ecca3;
            font-weight: bold;
        }

        .inventory {
            margin-top: 10px;
            padding: 10px;
            background: #0a0a14;
            border-radius: 6px;
        }

        .inventory h4 {
            color: #4ecca3;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .inventory-items {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            min-height: 30px;
        }

        .inventory-item {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .item-yellow { background: #ffd700; }
        .item-green { background: #4ecca3; }
        .item-blue { background: #3498db; }

        .inventory-empty {
            color: #555;
            font-size: 12px;
            font-style: italic;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 450px;
        }

        .console-section {
            background: #16213e;
            border-radius: 8px;
            border: 2px solid #0f3460;
            overflow: hidden;
        }

        .console-header {
            background: #0f3460;
            padding: 10px 15px;
            font-weight: bold;
            color: #4ecca3;
        }

        #commandInput {
            width: 100%;
            height: 220px;
            background: #0a0a14;
            color: #4ecca3;
            border: none;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
        }

        #commandInput::placeholder {
            color: #555;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-generate {
            background: #e94560;
            color: white;
        }

        .btn-generate:hover {
            background: #ff6b6b;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .btn-run {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .btn-run:hover {
            background: #6effc0;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78, 204, 163, 0.4);
        }

        .btn-restart {
            background: #f39c12;
            color: #1a1a2e;
        }

        .btn-restart:hover {
            background: #f5b041;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .btn-clear {
            background: #533483;
            color: white;
        }

        .btn-clear:hover {
            background: #7b5ab7;
            transform: translateY(-2px);
        }

        .instructions {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #0f3460;
            font-size: 12px;
            line-height: 1.5;
        }

        .instructions h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .instructions code {
            background: #0a0a14;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4ecca3;
        }

        .instructions ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid #fff;
        }

        .legend-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        .status-message {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            font-weight: bold;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-waiting {
            background: #533483;
            color: #fff;
        }

        .status-running {
            background: #f39c12;
            color: #fff;
        }

        .status-success {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .status-failed {
            background: #e94560;
            color: #fff;
        }

        .status-dead {
            background: #8b0000;
            color: #fff;
        }

        .command-history {
            background: #0a0a14;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
        }

        .command-line {
            padding: 3px 0;
            border-bottom: 1px solid #1a1a2e;
        }

        .command-success {
            color: #4ecca3;
        }

        .command-error {
            color: #e94560;
        }

        .command-info {
            color: #f39c12;
        }

        .command-dead {
            color: #ff4444;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>CODE COLLECTOR</h1>
    
    <div class="game-container">
        <div class="left-panel">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            
            <div class="info-panel">
                <h3>Game Status</h3>
                <div class="stats">
                    <div class="stat">
                        <span>Delivered:</span>
                        <span class="stat-value" id="resourceCount">0/0</span>
                    </div>
                    <div class="stat">
                        <span>Steps:</span>
                        <span class="stat-value" id="stepCount">0</span>
                    </div>
                    <div class="stat">
                        <span>Pos:</span>
                        <span class="stat-value" id="playerPos">0,0</span>
                    </div>
                    <div class="stat">
                        <span>Health:</span>
                        <span class="stat-value" id="healthStatus">OK</span>
                    </div>
                </div>
                
                <div class="inventory">
                    <h4>Inventory (Max 3): <span id="inventoryCount">0/3</span></h4>
                    <div class="inventory-items" id="inventoryItems">
                        <span class="inventory-empty">Empty</span>
                    </div>
                </div>
            </div>
            
            <div id="statusMessage" class="status-message status-waiting">
                Press "Generate Task" to start
            </div>
        </div>
        
        <div class="right-panel">
            <div class="console-section">
                <div class="console-header">Command Console</div>
                <textarea id="commandInput" placeholder="Enter your commands here...

Example:
right 2
collect
bye right while coin
collect
down 3
drop

Colors: yellow, green, blue
Deliver to matching colored zones!"></textarea>
            </div>
            
            <div class="button-group">
                <button class="btn-generate" onclick="generateTask()">Generate Task</button>
                <button class="btn-restart" onclick="restartGame()">Restart</button>
                <button class="btn-run" onclick="runCommands()">Run Code</button>
                <button class="btn-clear" onclick="clearConsole()">Clear</button>
            </div>
            
            <div class="console-section">
                <div class="console-header">Execution Log</div>
                <div id="commandHistory" class="command-history">
                    <div class="command-line command-info">Ready to start...</div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>Available Commands</h3>
                <ul>
                    <li><code>up [n]</code> - Move up n times (default 1)</li>
                    <li><code>down [n]</code> - Move down n times (default 1)</li>
                    <li><code>left [n]</code> - Move left n times (default 1)</li>
                    <li><code>right [n]</code> - Move right n times (default 1)</li>
                    <li><code>bye [direction] [while coin]</code> - Move until blocked or coin found</li>
                    <li><code>collect</code> - Collect resource (max 3 in inventory)</li>
                    <li><code>drop</code> - Deliver resources to matching drop zone</li>
                </ul>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #ffd700;"></div>
                        <span>Yellow Resource</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #4ecca3;"></div>
                        <span>Green Resource</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #3498db;"></div>
                        <span>Blue Resource</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #b8860b;"></div>
                        <span>Yellow Drop</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2e8b57;"></div>
                        <span>Green Drop</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #1e6091;"></div>
                        <span>Blue Drop</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8b0000;"></div>
                        <span>DANGER</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #555;"></div>
                        <span>Wall</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 10;
        const CELL_SIZE = 40;
        const MAX_INVENTORY = 3;
        
        const COLORS = {
            yellow: { resource: '#ffd700', drop: '#b8860b', light: '#ffeb99' },
            green: { resource: '#4ecca3', drop: '#2e8b57', light: '#99ffcc' },
            blue: { resource: '#3498db', drop: '#1e6091', light: '#99ccff' }
        };
        
        const initialState = {
            grid: [],
            player: { x: 0, y: 0 },
            resources: [],
            walls: [],
            dangerZones: [],
            dropZones: [],
            inventory: [],
            delivered: 0,
            totalResources: 0,
            steps: 0,
            isRunning: false,
            gameEnded: false,
            playerDead: false,
            originalPlayer: { x: 0, y: 0 },
            originalResources: [],
            originalGrid: [],
            originalInventory: [],
            originalDelivered: 0
        };

        let gameState = JSON.parse(JSON.stringify(initialState));

        // Initialize empty grid
        function initGrid() {
            gameState.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    gameState.grid[y][x] = 'empty';
                }
            }
        }

        // Generate random task
        function generateTask() {
            initGrid();
            
            // Reset game state
            gameState.player = { x: 0, y: 0 };
            gameState.originalPlayer = { x: 0, y: 0 };
            gameState.resources = [];
            gameState.walls = [];
            gameState.dangerZones = [];
            gameState.dropZones = [];
            gameState.inventory = [];
            gameState.delivered = 0;
            gameState.totalResources = 0;
            gameState.steps = 0;
            gameState.isRunning = false;
            gameState.gameEnded = false;
            gameState.playerDead = false;
            
            // Generate walls (12-20 walls)
            const wallCount = Math.floor(Math.random() * 9) + 12;
            for (let i = 0; i < wallCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while ((x === 0 && y === 0) || gameState.grid[y][x] !== 'empty');
                
                gameState.grid[y][x] = 'wall';
                gameState.walls.push({ x, y });
            }
            
            // Generate danger zones (4-6 red cells)
            const dangerCount = Math.floor(Math.random() * 3) + 4;
            for (let i = 0; i < dangerCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while ((x === 0 && y === 0) || gameState.grid[y][x] !== 'empty');
                
                gameState.grid[y][x] = 'danger';
                gameState.dangerZones.push({ x, y });
            }
            
            // Generate resources and drop zones for each color
            const colors = ['yellow', 'green', 'blue'];
            colors.forEach(color => {
                // Generate 2-4 resources of this color
                const resourceCount = Math.floor(Math.random() * 3) + 2;
                for (let i = 0; i < resourceCount; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * GRID_SIZE);
                        y = Math.floor(Math.random() * GRID_SIZE);
                    } while ((x === 0 && y === 0) || gameState.grid[y][x] !== 'empty');
                    
                    gameState.grid[y][x] = `resource_${color}`;
                    gameState.resources.push({ x, y, color, collected: false, delivered: false });
                }
                
                // Generate 1 drop zone for this color
                let dx, dy;
                do {
                    dx = Math.floor(Math.random() * GRID_SIZE);
                    dy = Math.floor(Math.random() * GRID_SIZE);
                } while ((dx === 0 && dy === 0) || gameState.grid[dy][dx] !== 'empty');
                
                gameState.grid[dy][dx] = `drop_${color}`;
                gameState.dropZones.push({ x: dx, y: dy, color });
                
                gameState.totalResources += resourceCount;
            });
            
            // Store original state for restart
            saveOriginalState();
            
            // Clear history and update status
            clearHistory();
            addToHistory('New task generated!', 'info');
            addToHistory(`Collect ${gameState.totalResources} resources and deliver to matching zones!`, 'info');
            updateStatus('Task ready - Write your code!', 'waiting');
            updateStats();
            draw();
        }

        // Save original state for restart
        function saveOriginalState() {
            gameState.originalPlayer = { ...gameState.player };
            gameState.originalResources = gameState.resources.map(r => ({ ...r }));
            gameState.originalGrid = gameState.grid.map(row => [...row]);
            gameState.originalInventory = [];
            gameState.originalDelivered = 0;
        }

        // Restart game with same layout
        function restartGame() {
            if (gameState.originalGrid.length === 0) {
                addToHistory('No task to restart. Generate a task first!', 'error');
                return;
            }
            
            // Restore original state
            gameState.player = { ...gameState.originalPlayer };
            gameState.resources = gameState.originalResources.map(r => ({ ...r }));
            gameState.grid = gameState.originalGrid.map(row => [...row]);
            gameState.inventory = [];
            gameState.delivered = 0;
            gameState.steps = 0;
            gameState.isRunning = false;
            gameState.gameEnded = false;
            gameState.playerDead = false;
            
            clearHistory();
            addToHistory('Game restarted with same layout!', 'info');
            updateStatus('Task restarted - Write your code!', 'waiting');
            updateStats();
            draw();
        }

        // Draw the game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, GRID_SIZE * CELL_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(GRID_SIZE * CELL_SIZE, i * CELL_SIZE);
                ctx.stroke();
            }
            
            // Draw drop zones (lighter colored cells)
            gameState.dropZones.forEach(drop => {
                ctx.fillStyle = COLORS[drop.color].drop;
                ctx.fillRect(
                    drop.x * CELL_SIZE + 1,
                    drop.y * CELL_SIZE + 1,
                    CELL_SIZE - 2,
                    CELL_SIZE - 2
                );
                
                // Draw letter indicating drop zone
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    drop.color[0].toUpperCase(),
                    drop.x * CELL_SIZE + CELL_SIZE / 2,
                    drop.y * CELL_SIZE + CELL_SIZE / 2
                );
            });
            
            // Draw danger zones (red cells)
            gameState.dangerZones.forEach(danger => {
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(
                    danger.x * CELL_SIZE + 1,
                    danger.y * CELL_SIZE + 1,
                    CELL_SIZE - 2,
                    CELL_SIZE - 2
                );
                
                // Add hazard pattern
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(danger.x * CELL_SIZE + 5, danger.y * CELL_SIZE + 5);
                ctx.lineTo((danger.x + 1) * CELL_SIZE - 5, (danger.y + 1) * CELL_SIZE - 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo((danger.x + 1) * CELL_SIZE - 5, danger.y * CELL_SIZE + 5);
                ctx.lineTo(danger.x * CELL_SIZE + 5, (danger.y + 1) * CELL_SIZE - 5);
                ctx.stroke();
            });
            
            // Draw walls
            ctx.fillStyle = '#555';
            gameState.walls.forEach(wall => {
                ctx.fillRect(
                    wall.x * CELL_SIZE + 2,
                    wall.y * CELL_SIZE + 2,
                    CELL_SIZE - 4,
                    CELL_SIZE - 4
                );
            });
            
            // Draw resources
            gameState.resources.forEach(resource => {
                if (!resource.collected) {
                    ctx.fillStyle = COLORS[resource.color].resource;
                    ctx.beginPath();
                    ctx.arc(
                        resource.x * CELL_SIZE + CELL_SIZE / 2,
                        resource.y * CELL_SIZE + CELL_SIZE / 2,
                        CELL_SIZE / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Glow effect
                    ctx.shadowColor = COLORS[resource.color].resource;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw player
            if (!gameState.playerDead) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(
                    gameState.player.x * CELL_SIZE + 5,
                    gameState.player.y * CELL_SIZE + 5,
                    CELL_SIZE - 10,
                    CELL_SIZE - 10
                );
                
                // Player glow
                ctx.shadowColor = '#4ecca3';
                ctx.shadowBlur = 15;
                ctx.fillRect(
                    gameState.player.x * CELL_SIZE + 5,
                    gameState.player.y * CELL_SIZE + 5,
                    CELL_SIZE - 10,
                    CELL_SIZE - 10
                );
                ctx.shadowBlur = 0;
                
                // Draw inventory indicator on player
                if (gameState.inventory.length > 0) {
                    ctx.fillStyle = COLORS[gameState.inventory[0]].resource;
                    ctx.beginPath();
                    ctx.arc(
                        gameState.player.x * CELL_SIZE + CELL_SIZE / 2,
                        gameState.player.y * CELL_SIZE + CELL_SIZE / 2,
                        6,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        }

        // Execute commands
        async function runCommands() {
            if (gameState.isRunning) {
                return;
            }
            
            if (gameState.gameEnded) {
                addToHistory('Game ended. Restart or generate new task to play again.', 'error');
                return;
            }
            
            const input = document.getElementById('commandInput').value.trim();
            if (!input) {
                addToHistory('Please enter commands first!', 'error');
                return;
            }
            
            gameState.isRunning = true;
            updateStatus('Running code...', 'running');
            clearHistory();
            addToHistory('Starting execution...', 'info');
            
            const lines = input.split('\n').map(line => line.trim()).filter(line => line);
            
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                const parts = line.split(/\s+/);
                const command = parts[0].toLowerCase();
                
                addToHistory(`> ${line}`, 'info');
                
                let result;
                
                if (command === 'bye') {
                    // bye command - parse direction and optional "while coin"
                    const direction = parts[1] ? parts[1].toLowerCase() : null;
                    if (!direction || !['up', 'down', 'left', 'right'].includes(direction)) {
                        result = { success: false, message: 'bye command requires a valid direction (up/down/left/right)' };
                    } else {
                        // Check for "while coin" modifier
                        const whileCoin = parts.length >= 4 && 
                                         parts[2].toLowerCase() === 'while' && 
                                         parts[3].toLowerCase() === 'coin';
                        result = await executeByeCommand(direction, whileCoin);
                    }
                } else if (['up', 'down', 'left', 'right'].includes(command)) {
                    // Movement command with optional coefficient
                    const coefficient = parts[1] ? parseInt(parts[1]) : 1;
                    if (isNaN(coefficient) || coefficient < 1) {
                        result = { success: false, message: `Invalid coefficient: "${parts[1]}"` };
                    } else {
                        result = await executeMovementCommand(command, coefficient);
                    }
                } else if (command === 'collect') {
                    result = collectResource();
                } else if (command === 'drop') {
                    result = dropResource();
                } else {
                    result = { success: false, message: `Unknown command: "${command}"` };
                }
                
                if (result.success) {
                    addToHistory(result.message, 'success');
                } else {
                    addToHistory(result.message, result.dead ? 'dead' : 'error');
                    if (result.dead) {
                        gameState.playerDead = true;
                        gameState.gameEnded = true;
                        draw();
                        updateStatus('GAME OVER - You died!', 'dead');
                        gameState.isRunning = false;
                        return;
                    }
                    break;
                }
                
                // Check win condition
                if (gameState.delivered === gameState.totalResources) {
                    updateStatus(`SUCCESS! All resources delivered in ${gameState.steps} steps!`, 'success');
                    addToHistory('ðŸŽ‰ All resources delivered!', 'success');
                    gameState.gameEnded = true;
                    gameState.isRunning = false;
                    return;
                }
                
                // Small delay for visualization
                await sleep(200);
            }
            
            gameState.isRunning = false;
            
            if (!gameState.gameEnded) {
                if (gameState.delivered < gameState.totalResources) {
                    updateStatus('Code execution complete. Resources remain undelivered!', 'failed');
                    addToHistory('Execution complete. Not all resources delivered.', 'error');
                    gameState.gameEnded = true;
                }
            }
        }

        // Execute bye command (move until blocked or coin found)
        async function executeByeCommand(direction, whileCoin) {
            let dx = 0, dy = 0;
            switch (direction) {
                case 'up': dy = -1; break;
                case 'down': dy = 1; break;
                case 'left': dx = -1; break;
                case 'right': dx = 1; break;
            }
            
            let moveCount = 0;
            
            while (true) {
                const newX = gameState.player.x + dx;
                const newY = gameState.player.y + dy;
                
                // Check bounds
                if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                    break;
                }
                
                // Check walls
                if (gameState.grid[newY][newX] === 'wall') {
                    break;
                }
                
                // Check danger zones
                if (gameState.grid[newY][newX] === 'danger') {
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                    moveCount++;
                    gameState.steps++;
                    draw();
                    return { 
                        success: false, 
                        dead: true,
                        message: `Moved ${direction} ${moveCount} time(s) and entered a DANGER ZONE! ðŸ’€` 
                    };
                }
                
                // Move player
                gameState.player.x = newX;
                gameState.player.y = newY;
                moveCount++;
                gameState.steps++;
                
                draw();
                await sleep(150);
                
                // Check for coin if whileCoin is enabled
                if (whileCoin) {
                    const resource = gameState.resources.find(
                        r => r.x === gameState.player.x && r.y === gameState.player.y && !r.collected
                    );
                    if (resource) {
                        return { success: true, message: `Moved ${direction} ${moveCount} time(s) and found a ${resource.color} coin!` };
                    }
                }
            }
            
            if (moveCount === 0) {
                return { success: false, message: `Cannot move ${direction}: Blocked immediately!` };
            }
            
            const condition = whileCoin ? "until blocked (no coin found)" : "until blocked";
            return { success: true, message: `Moved ${direction} ${moveCount} time(s) ${condition}` };
        }

        // Execute movement command with coefficient
        async function executeMovementCommand(direction, coefficient) {
            let dx = 0, dy = 0;
            switch (direction) {
                case 'up': dy = -1; break;
                case 'down': dy = 1; break;
                case 'left': dx = -1; break;
                case 'right': dx = 1; break;
            }
            
            for (let i = 0; i < coefficient; i++) {
                const result = movePlayer(dx, dy);
                
                if (result.dead) {
                    return result;
                }
                
                if (!result.success) {
                    if (i === 0) {
                        return result;
                    } else {
                        return { success: true, message: `Moved ${direction} ${i} time(s), then blocked` };
                    }
                }
                
                draw();
                await sleep(150);
            }
            
            return { success: true, message: `Moved ${direction} ${coefficient} time(s)` };
        }

        // Move player
        function movePlayer(dx, dy) {
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;
            
            // Check bounds
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                return { success: false, message: 'Cannot move: Out of bounds!' };
            }
            
            // Check walls
            if (gameState.grid[newY][newX] === 'wall') {
                return { success: false, message: 'Cannot move: Wall in the way!' };
            }
            
            // Check danger zones
            if (gameState.grid[newY][newX] === 'danger') {
                gameState.player.x = newX;
                gameState.player.y = newY;
                return { 
                    success: false, 
                    dead: true,
                    message: 'You entered a DANGER ZONE and died! ðŸ’€' 
                };
            }
            
            gameState.player.x = newX;
            gameState.player.y = newY;
            
            const dir = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'down' : 'up';
            return { success: true, message: `Moved ${dir} to (${newX}, ${newY})` };
        }

        // Collect resource
        function collectResource() {
            if (gameState.inventory.length >= MAX_INVENTORY) {
                return { success: false, message: `Inventory full! Max ${MAX_INVENTORY} items. Deliver some first!` };
            }
            
            const resource = gameState.resources.find(
                r => r.x === gameState.player.x && r.y === gameState.player.y && !r.collected
            );
            
            if (resource) {
                resource.collected = true;
                gameState.inventory.push(resource.color);
                updateStats();
                return { success: true, message: `Collected ${resource.color} resource! (${gameState.inventory.length}/${MAX_INVENTORY})` };
            }
            
            return { success: false, message: 'No resource to collect at current position!' };
        }

        // Drop/deliver resource
        function dropResource() {
            // Check if player is on a drop zone
            const dropZone = gameState.dropZones.find(
                d => d.x === gameState.player.x && d.y === gameState.player.y
            );
            
            if (!dropZone) {
                return { success: false, message: 'Not on a delivery zone! Find a colored base.' };
            }
            
            // Check if player has resources of matching color
            const matchingResources = gameState.inventory.filter(color => color === dropZone.color);
            
            if (matchingResources.length === 0) {
                return { success: false, message: `No ${dropZone.color} resources to deliver here!` };
            }
            
            // Deliver all matching resources
            let deliveredCount = 0;
            gameState.inventory = gameState.inventory.filter(color => {
                if (color === dropZone.color) {
                    deliveredCount++;
                    gameState.delivered++;
                    
                    // Mark the corresponding resource as delivered
                    const resource = gameState.resources.find(
                        r => r.color === color && r.collected && !r.delivered
                    );
                    if (resource) {
                        resource.delivered = true;
                    }
                    
                    return false;
                }
                return true;
            });
            
            updateStats();
            return { success: true, message: `Delivered ${deliveredCount} ${dropZone.color} resource(s)!` };
        }

        // Utility functions
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function updateStats() {
            document.getElementById('resourceCount').textContent = 
                `${gameState.delivered}/${gameState.totalResources}`;
            document.getElementById('stepCount').textContent = gameState.steps;
            document.getElementById('playerPos').textContent = 
                `${gameState.player.x},${gameState.player.y}`;
            document.getElementById('healthStatus').textContent = 
                gameState.playerDead ? 'DEAD' : 'OK';
            document.getElementById('healthStatus').style.color = 
                gameState.playerDead ? '#ff4444' : '#4ecca3';
            
            // Update inventory display
            document.getElementById('inventoryCount').textContent = 
                `${gameState.inventory.length}/${MAX_INVENTORY}`;
            
            const inventoryItemsEl = document.getElementById('inventoryItems');
            if (gameState.inventory.length === 0) {
                inventoryItemsEl.innerHTML = '<span class="inventory-empty">Empty</span>';
            } else {
                inventoryItemsEl.innerHTML = gameState.inventory.map(color => 
                    `<div class="inventory-item item-${color}"></div>`
                ).join('');
            }
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
        }

        function addToHistory(message, type) {
            const historyEl = document.getElementById('commandHistory');
            const line = document.createElement('div');
            line.className = `command-line command-${type}`;
            line.textContent = message;
            historyEl.appendChild(line);
            historyEl.scrollTop = historyEl.scrollHeight;
        }

        function clearHistory() {
            document.getElementById('commandHistory').innerHTML = '';
        }

        function clearConsole() {
            document.getElementById('commandInput').value = '';
            clearHistory();
            addToHistory('Console cleared.', 'info');
        }

        // Initial draw
        initGrid();
        draw();
    </script>
</body>
</html>
