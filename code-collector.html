<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Collector - Screeps-like Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: #4ecca3;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(78, 204, 163, 0.5);
        }

        .game-container {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #gameCanvas {
            border: 3px solid #4ecca3;
            border-radius: 8px;
            background: #0f0f1a;
            box-shadow: 0 0 20px rgba(78, 204, 163, 0.3);
        }

        .info-panel {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #0f3460;
        }

        .info-panel h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            gap: 15px;
            font-size: 13px;
            flex-wrap: wrap;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-value {
            color: #4ecca3;
            font-weight: bold;
        }

        .inventory {
            margin-top: 10px;
            padding: 10px;
            background: #0a0a14;
            border-radius: 6px;
        }

        .inventory h4 {
            color: #4ecca3;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .inventory-items {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            min-height: 30px;
        }

        .inventory-item {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .item-yellow { background: #ffd700; }
        .item-green { background: #4ecca3; }
        .item-blue { background: #3498db; }

        .inventory-empty {
            color: #555;
            font-size: 12px;
            font-style: italic;
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 460px;
        }

        .console-section {
            background: #16213e;
            border-radius: 8px;
            border: 2px solid #0f3460;
            overflow: hidden;
        }

        .console-header {
            background: #0f3460;
            padding: 10px 15px;
            font-weight: bold;
            color: #4ecca3;
        }

        #commandInput {
            width: 100%;
            height: 220px;
            background: #0a0a14;
            color: #4ecca3;
            border: none;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
        }

        #commandInput::placeholder {
            color: #555;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        button {
            flex: 1;
            padding: 12px 15px;
            border: none;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-generate {
            background: #e94560;
            color: white;
        }

        .btn-generate:hover {
            background: #ff6b6b;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }

        .btn-run {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .btn-run:hover {
            background: #6effc0;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78, 204, 163, 0.4);
        }

        .btn-restart {
            background: #f39c12;
            color: #1a1a2e;
        }

        .btn-restart:hover {
            background: #f5b041;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.4);
        }

        .btn-clear {
            background: #533483;
            color: white;
        }

        .btn-clear:hover {
            background: #7b5ab7;
            transform: translateY(-2px);
        }

        .instructions {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #0f3460;
            font-size: 11px;
            line-height: 1.4;
        }

        .instructions h3 {
            color: #e94560;
            margin-bottom: 10px;
        }

        .instructions code {
            background: #0a0a14;
            padding: 2px 6px;
            border-radius: 3px;
            color: #4ecca3;
        }

        .instructions ul {
            margin-left: 20px;
            margin-top: 10px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 10px;
        }

        .legend-color {
            width: 14px;
            height: 14px;
            border-radius: 3px;
            border: 1px solid #fff;
        }

        .legend-circle {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        .status-message {
            text-align: center;
            padding: 10px;
            border-radius: 6px;
            font-weight: bold;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-waiting {
            background: #533483;
            color: #fff;
        }

        .status-running {
            background: #f39c12;
            color: #fff;
        }

        .status-success {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .status-failed {
            background: #e94560;
            color: #fff;
        }

        .status-dead {
            background: #8b0000;
            color: #fff;
        }

        .command-history {
            background: #0a0a14;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 12px;
        }

        .command-line {
            padding: 3px 0;
            border-bottom: 1px solid #1a1a2e;
        }

        .command-success {
            color: #4ecca3;
        }

        .command-error {
            color: #e94560;
        }

        .command-info {
            color: #f39c12;
        }

        .command-dead {
            color: #ff4444;
            font-weight: bold;
        }

        .command-rev {
            color: #00ffff;
        }

        /* Labyrinth Minigame Modal */
        .labyrinth-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .labyrinth-modal.active {
            display: flex;
        }

        .labyrinth-container {
            background: #1a1a2e;
            border: 3px solid #e94560;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
        }

        .labyrinth-title {
            color: #e94560;
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }

        .labyrinth-canvas {
            border: 2px solid #4ecca3;
            background: #0f0f1a;
        }

        .labyrinth-instructions {
            color: #4ecca3;
            text-align: center;
            margin-top: 15px;
            font-size: 12px;
        }

        .labyrinth-status {
            color: #ffd700;
            text-align: center;
            margin-top: 10px;
            font-size: 14px;
            min-height: 20px;
        }
    </style>
</head>
<body>
    <h1>CODE COLLECTOR</h1>
    
    <div class="game-container">
        <div class="left-panel">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            
            <div id="canvasSeedDisplay" style="margin-top: 8px; padding: 8px 12px; background: rgba(0, 0, 0, 0.85); border: 2px solid #4ecca3; border-radius: 4px; color: #4ecca3; font-family: 'Courier New', monospace; font-size: 14px; font-weight: bold; text-align: center; display: none;">
                Seed: <span id="canvasSeedValue"></span>
            </div>
            
            <div class="info-panel">
                <h3>Game Status</h3>
                <div class="stats">
                    <div class="stat">
                        <span>Delivered:</span>
                        <span class="stat-value" id="resourceCount">0/0</span>
                    </div>
                    <div class="stat">
                        <span>Steps:</span>
                        <span class="stat-value" id="stepCount">0</span>
                    </div>
                    <div class="stat">
                        <span>Pos:</span>
                        <span class="stat-value" id="playerPos">0,0</span>
                    </div>
                    <div class="stat">
                        <span>Health:</span>
                        <span class="stat-value" id="healthStatus">OK</span>
                    </div>
                </div>
                
                <div class="inventory">
                    <h4>Inventory (Max 3): <span id="inventoryCount">0/3</span></h4>
                    <div class="inventory-items" id="inventoryItems">
                        <span class="inventory-empty">Empty</span>
                    </div>
                </div>
            </div>
            
            <div id="statusMessage" class="status-message status-waiting">
                Press "Generate Task" to start
            </div>
        </div>
        
        <div class="right-panel">
            <div class="console-section">
                <div class="console-header">Command Console</div>
                <textarea id="commandInput" placeholder="Enter your commands here...

Example with rev/repeat:
right 3
down 2
left
collect
rev repeat 4    # Will do: right, up 2, left 3

Use 'stop n' to wait while blocks move:
stop 3          # Wait 3 turns (blocks keep moving!)

Note: Failed 'collect'/'drop' become 'stop 1'

Teleport colors: Purple (A), Orange (B)
Watch out for moving blocks!"></textarea>
            </div>
            
            <div class="button-group">
                <div style="display: flex; gap: 8px;">
                    <button class="btn-generate" onclick="generateTask()">Generate Task</button>
                    <button class="btn-restart" onclick="restartGame()">Restart</button>
                    <button class="btn-run" onclick="runCommands()">Run Code</button>
                    <button class="btn-clear" onclick="clearConsole()">Clear</button>
                </div>
                <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
                    <input type="text" id="seedInput" placeholder="Enter seed..." 
                           style="padding: 10px; border: 2px solid #0f3460; border-radius: 4px; 
                                  background: #0a0a14; color: #eee; font-family: inherit; font-size: 12px; 
                                  width: 140px;" maxlength="20">
                    <button onclick="applySeed()" style="padding: 10px 15px; background: #4ecca3; color: #0a0a14; border: none; border-radius: 4px; font-family: inherit; font-size: 12px; font-weight: bold; cursor: pointer;">Apply</button>
                    <span id="currentSeedDisplay" style="color: #4ecca3; font-size: 11px; display: none;"></span>
                </div>
            </div>
            
            <div class="console-section">
                <div class="console-header">Execution Log</div>
                <div id="commandHistory" class="command-history">
                    <div class="command-line command-info">Ready to start...</div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>Available Commands</h3>
                <ul>
                    <li><code>up [n]</code> - Move up n times</li>
                    <li><code>down [n]</code> - Move down n times</li>
                    <li><code>left [n]</code> - Move left n times</li>
                    <li><code>right [n]</code> - Move right n times</li>
                    <li><code>bye [dir] [while condition] [on pos]</code> - Move until blocked/condition (coin, portal, wall, mine, zone, door) at position (l=left, r=right, b=below, a=above)</li>
                    <li><code>collect</code> - Collect resource (max 3, becomes stop if no coin)</li>
                    <li><code>drop</code> - Deliver to matching zone (becomes stop if no zone)</li>
                    <li><code>rev [repeat n]</code> - Reverse last command(s)</li>
                    <li><code>repeat n</code> - Repeat last n commands</li>
                    <li><code>stop [n]</code> - Wait n turns (blocks move!)</li>
                </ul>
                <p style="margin-top: 8px; color: #00ffff;">
                    <strong>rev repeat n:</strong> Takes last n commands, reverses direction, and executes them!
                </p>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #ffd700;"></div>
                        <span>Yellow Coin</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #4ecca3;"></div>
                        <span>Green Coin</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle" style="background: #3498db;"></div>
                        <span>Blue Coin</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #b8860b;"></div>
                        <span>Yellow Drop</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2e8b57;"></div>
                        <span>Green Drop</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #1e6091;"></div>
                        <span>Blue Drop</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9932cc;"></div>
                        <span>Purple TP (A)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff8c00;"></div>
                        <span>Orange TP (B)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6600;"></div>
                        <span>Moving Block!</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8b0000;"></div>
                        <span>DANGER</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #8b4513;"></div>
                        <span>Locked Door</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 15;
        const CELL_SIZE = 40;
        
        // Seeded PRNG (Mulberry32)
        let seedState = 0;
        let currentSeed = '';
        
        function setSeed(seed) {
            currentSeed = seed;
            // Robust string hashing to 32-bit unsigned integer
            let h = 0x811c9dc5; // FNV-1a offset basis
            for (let i = 0; i < seed.length; i++) {
                h ^= seed.charCodeAt(i);
                h = Math.imul(h, 0x01000193); // FNV-1a prime
            }
            // Ensure non-zero state and apply MurmurHash3 finalizer
            h = h >>> 0;
            if (h === 0) h = 1;
            h ^= h >>> 16;
            h = Math.imul(h, 0x21f0aaad);
            h ^= h >>> 15;
            h = Math.imul(h, 0x735a2d97);
            h ^= h >>> 15;
            seedState = h >>> 0;
        }
        
        function seededRandom() {
            // Mulberry32 algorithm
            let z = (seedState += 0x6D2B79F5) >>> 0;
            z = (Math.imul(z ^ (z >>> 15), z | 1)) >>> 0;
            z ^= z + Math.imul(z ^ (z >>> 7), z | 61);
            return ((z ^ (z >>> 14)) >>> 0) / 4294967296;
        }
        
        function generateRandomSeed() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const length = Math.floor(Math.random() * 3) + 6; // 6 to 8 characters
            let seed = '';
            for (let i = 0; i < length; i++) {
                seed += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return seed;
        }
        const MAX_INVENTORY = 3;
        
        const COLORS = {
            yellow: { resource: '#ffd700', drop: '#b8860b', light: '#ffeb99' },
            green: { resource: '#4ecca3', drop: '#2e8b57', light: '#99ffcc' },
            blue: { resource: '#3498db', drop: '#1e6091', light: '#99ccff' },
            teleporterPurple: '#9932cc',
            teleporterOrange: '#ff8c00',
            movingBlock: '#ff6600'
        };
        
        const DIRECTION_OPPOSITES = {
            'up': 'down',
            'down': 'up',
            'left': 'right',
            'right': 'left'
        };
        
        const initialState = {
            grid: [],
            player: { x: 0, y: 0 },
            resources: [],
            walls: [],
            dangerZones: [],
            dropZones: [],
            teleporters: [],
            movingBlocks: [],
            inventory: [],
            delivered: 0,
            totalResources: 0,
            steps: 0,
            isRunning: false,
            gameEnded: false,
            playerDead: false,
            originalPlayer: { x: 0, y: 0 },
            originalResources: [],
            originalGrid: [],
            originalInventory: [],
            originalDelivered: 0,
            originalMovingBlocks: [],
            doorStructure: null,
            labyrinthCompleted: false,
            labyrinthActive: false
        };

        let gameState = JSON.parse(JSON.stringify(initialState));
        let commandHistory = []; // Store executed commands for rev/repeat

        // Labyrinth minigame state
        const LABYRINTH_WIDTH = 20;
        const LABYRINTH_HEIGHT = 12;
        const LABYRINTH_CELL_SIZE = 35;
        let labyrinthState = {
            player: { x: 0, y: 0 },
            exit: { x: 0, y: 0 },
            dangerZones: [],
            grid: []
        };

        // Initialize empty grid
        function initGrid() {
            gameState.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                gameState.grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    gameState.grid[y][x] = 'empty';
                }
            }
        }

        // Generate door structure with 7 walls and 1 door
        function generateDoorStructure() {
            // Create a 3x3 square structure somewhere on the grid
            // Structure layout:
            // W W W
            // W C D  (W=wall, C=coin inside, D=door)
            // W W W
            // This uses 7 walls, 1 door, with empty cell inside containing coin
            
            // Generate a list of all valid positions first
            const validPositions = [];
            for (let sy = 2; sy <= GRID_SIZE - 5; sy++) {
                for (let sx = 4; sx <= GRID_SIZE - 7; sx++) {
                    // Check if 3x3 area is clear
                    let areaClear = true;
                    for (let y = sy; y < sy + 3; y++) {
                        for (let x = sx; x < sx + 3; x++) {
                            if ((x === 0 && y === 0) || gameState.grid[y][x] !== 'empty') {
                                areaClear = false;
                                break;
                            }
                        }
                        if (!areaClear) break;
                    }
                    // Check that cell in front of door is empty
                    if (areaClear) {
                        const frontCellX = sx + 3;
                        const frontCellY = sy + 1;
                        if (frontCellX < GRID_SIZE && gameState.grid[frontCellY][frontCellX] === 'empty') {
                            validPositions.push({ startX: sx, startY: sy });
                        }
                    }
                }
            }
            
            // Use seeded random to pick from valid positions
            // If no valid positions, use a default position (should not happen with empty grid)
            let startX, startY;
            if (validPositions.length === 0) {
                startX = 4;
                startY = 2;
            } else {
                const idx = Math.floor(seededRandom() * validPositions.length);
                ({ startX, startY } = validPositions[idx]);
            }
            
            // Place walls (7 walls in a U shape with one side open for door)
            const walls = [];
            // Top row
            walls.push({ x: startX, y: startY });
            walls.push({ x: startX + 1, y: startY });
            walls.push({ x: startX + 2, y: startY });
            // Left side
            walls.push({ x: startX, y: startY + 1 });
            walls.push({ x: startX, y: startY + 2 });
            // Bottom row
            walls.push({ x: startX + 1, y: startY + 2 });
            walls.push({ x: startX + 2, y: startY + 2 });
            
            // Place door on the right side (middle)
            const doorPos = { x: startX + 2, y: startY + 1 };
            gameState.grid[doorPos.y][doorPos.x] = 'door';
            
            // Inside cell (where coin will be)
            const insidePos = { x: startX + 1, y: startY + 1 };
            
            // Mark all positions
            walls.forEach(wall => {
                gameState.grid[wall.y][wall.x] = 'wall';
                gameState.walls.push(wall);
            });
            
            // Store door structure info
            gameState.doorStructure = {
                walls: walls,
                door: doorPos,
                inside: insidePos,
                isOpen: false,
                labyrinthTriggered: false
            };
            
            // Add coin inside
            gameState.grid[insidePos.y][insidePos.x] = 'resource_yellow';
            gameState.resources.push({ 
                x: insidePos.x, 
                y: insidePos.y, 
                color: 'yellow', 
                collected: false, 
                delivered: false 
            });
        }

        // Apply user-entered seed
        function applySeed() {
            const seedInput = document.getElementById('seedInput');
            const seed = seedInput.value.trim();
            
            if (!seed) {
                alert('Please enter a seed first');
                return;
            }
            
            // Use the entered seed to generate the level
            generateTaskWithSeed(seed);
        }

        // Generate task with a specific seed
        function generateTaskWithSeed(seed) {
            const seedInput = document.getElementById('seedInput');
            const seedDisplay = document.getElementById('currentSeedDisplay');
            
            // Set the seed in the input field
            seedInput.value = seed;
            
            setSeed(seed);
            seedDisplay.textContent = `Seed: ${seed}`;
            seedDisplay.style.display = 'inline';
            
            // Update canvas seed display
            const canvasSeedDisplay = document.getElementById('canvasSeedDisplay');
            const canvasSeedValue = document.getElementById('canvasSeedValue');
            if (canvasSeedDisplay && canvasSeedValue) {
                canvasSeedValue.textContent = seed;
                canvasSeedDisplay.style.display = 'block';
            }
            
            initGrid();
            commandHistory = []; // Reset command history
            
            // Reset game state
            gameState.player = { x: 0, y: 0 };
            gameState.originalPlayer = { x: 0, y: 0 };
            gameState.resources = [];
            gameState.walls = [];
            gameState.dangerZones = [];
            gameState.dropZones = [];
            gameState.teleporters = [];
            gameState.movingBlocks = [];
            gameState.inventory = [];
            gameState.delivered = 0;
            gameState.totalResources = 0;
            gameState.steps = 0;
            gameState.isRunning = false;
            gameState.gameEnded = false;
            gameState.playerDead = false;
            gameState.doorStructure = null;
            gameState.labyrinthCompleted = false;
            gameState.labyrinthActive = false;
            
            // Generate door structure with 7 walls and 1 door
            generateDoorStructure();
            
            // Generate walls (15-22 walls)
            const wallCount = Math.floor(seededRandom() * 8) + 15;
            let emptyCells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x !== 0 || y !== 0) && gameState.grid[y][x] === 'empty') {
                        emptyCells.push({ x, y });
                    }
                }
            }
            
            for (let i = 0; i < wallCount && emptyCells.length > 0; i++) {
                const idx = Math.floor(seededRandom() * emptyCells.length);
                const { x, y } = emptyCells.splice(idx, 1)[0];
                
                gameState.grid[y][x] = 'wall';
                gameState.walls.push({ x, y });
            }
            
            // Generate danger zones (18-22 red cells)
            const dangerCount = Math.floor(seededRandom() * 5) + 18;
            // Rebuild empty cells list
            emptyCells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x !== 0 || y !== 0) && gameState.grid[y][x] === 'empty') {
                        emptyCells.push({ x, y });
                    }
                }
            }
            
            for (let i = 0; i < dangerCount && emptyCells.length > 0; i++) {
                const idx = Math.floor(seededRandom() * emptyCells.length);
                const { x, y } = emptyCells.splice(idx, 1)[0];
                
                gameState.grid[y][x] = 'danger';
                gameState.dangerZones.push({ x, y });
            }
            
            // Generate purple teleporter pair (id: 0)
            // Rebuild empty cells list
            emptyCells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x !== 0 || y !== 0) && gameState.grid[y][x] === 'empty') {
                        emptyCells.push({ x, y });
                    }
                }
            }
            
            let px1, py1, px2, py2;
            if (emptyCells.length >= 2) {
                let idx = Math.floor(seededRandom() * emptyCells.length);
                ({ x: px1, y: py1 } = emptyCells.splice(idx, 1)[0]);
                gameState.grid[py1][px1] = 'teleporter_0_purple';
                
                idx = Math.floor(seededRandom() * emptyCells.length);
                ({ x: px2, y: py2 } = emptyCells.splice(idx, 1)[0]);
                gameState.grid[py2][px2] = 'teleporter_0_purple';
                
                gameState.teleporters.push({
                    id: 0,
                    color: 'purple',
                    pair: [{ x: px1, y: py1 }, { x: px2, y: py2 }]
                });
            }
            
            // Generate orange teleporter pair (id: 1)
            // Rebuild empty cells list
            emptyCells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x !== 0 || y !== 0) && gameState.grid[y][x] === 'empty') {
                        emptyCells.push({ x, y });
                    }
                }
            }
            
            let ox1, oy1, ox2, oy2;
            if (emptyCells.length >= 2) {
                let idx = Math.floor(seededRandom() * emptyCells.length);
                ({ x: ox1, y: oy1 } = emptyCells.splice(idx, 1)[0]);
                gameState.grid[oy1][ox1] = 'teleporter_1_orange';
                
                idx = Math.floor(seededRandom() * emptyCells.length);
                ({ x: ox2, y: oy2 } = emptyCells.splice(idx, 1)[0]);
                gameState.grid[oy2][ox2] = 'teleporter_1_orange';
                
                gameState.teleporters.push({
                    id: 1,
                    color: 'orange',
                    pair: [{ x: ox1, y: oy1 }, { x: ox2, y: oy2 }]
                });
            }
            
            // Generate moving blocks (3-5 moving blocks)
            const movingBlockCount = Math.floor(seededRandom() * 3) + 3;
            // Rebuild empty cells list
            emptyCells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x !== 0 || y !== 0) && gameState.grid[y][x] === 'empty') {
                        emptyCells.push({ x, y });
                    }
                }
            }
            
            for (let i = 0; i < movingBlockCount && emptyCells.length > 0; i++) {
                const idx = Math.floor(seededRandom() * emptyCells.length);
                const { x, y } = emptyCells.splice(idx, 1)[0];
                
                const isHorizontal = seededRandom() > 0.5;
                const dx = isHorizontal ? (seededRandom() > 0.5 ? 1 : -1) : 0;
                const dy = isHorizontal ? 0 : (seededRandom() > 0.5 ? 1 : -1);
                
                gameState.grid[y][x] = 'moving_block';
                gameState.movingBlocks.push({
                    x: x,
                    y: y,
                    dx: dx,
                    dy: dy,
                    id: i
                });
            }
            
            // Generate resources and drop zones for each color
            const colors = ['yellow', 'green', 'blue'];
            colors.forEach(color => {
                const resourceCount = Math.floor(seededRandom() * 3) + 2;
                
                // Rebuild empty cells list
                emptyCells = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if ((x !== 0 || y !== 0) && gameState.grid[y][x] === 'empty') {
                            emptyCells.push({ x, y });
                        }
                    }
                }
                
                for (let i = 0; i < resourceCount && emptyCells.length > 0; i++) {
                    const idx = Math.floor(seededRandom() * emptyCells.length);
                    const { x, y } = emptyCells.splice(idx, 1)[0];
                    
                    gameState.grid[y][x] = `resource_${color}`;
                    gameState.resources.push({ x, y, color, collected: false, delivered: false });
                }
                
                // Rebuild empty cells list for drop zone
                emptyCells = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if ((x !== 0 || y !== 0) && gameState.grid[y][x] === 'empty') {
                            emptyCells.push({ x, y });
                        }
                    }
                }
                
                if (emptyCells.length > 0) {
                    const idx = Math.floor(seededRandom() * emptyCells.length);
                    const { x: dx, y: dy } = emptyCells.splice(idx, 1)[0];
                    
                    gameState.grid[dy][dx] = `drop_${color}`;
                    gameState.dropZones.push({ x: dx, y: dy, color });
                }
                
                gameState.totalResources += resourceCount;
            });
            
            saveOriginalState();
            
            clearHistory();
            addToHistory('New task generated!', 'info');
            addToHistory(`Collect ${gameState.totalResources} resources and deliver!`, 'info');
            updateStatus('Task ready - Write your code!', 'waiting');
            updateStats();
            draw();
        }

        // Generate random task
        function generateTask() {
            // Generate a new random seed and use it
            const seed = generateRandomSeed();
            generateTaskWithSeed(seed);
        }

        // Save original state for restart
        function saveOriginalState() {
            gameState.originalPlayer = { ...gameState.player };
            gameState.originalResources = gameState.resources.map(r => ({ ...r }));
            gameState.originalGrid = gameState.grid.map(row => [...row]);
            gameState.originalInventory = [];
            gameState.originalDelivered = 0;
            gameState.originalMovingBlocks = gameState.movingBlocks.map(b => ({ ...b }));
        }

        // Restart game with same layout
        function restartGame() {
            if (gameState.originalGrid.length === 0) {
                addToHistory('No task to restart. Generate a task first!', 'error');
                return;
            }
            
            gameState.player = { ...gameState.originalPlayer };
            gameState.resources = gameState.originalResources.map(r => ({ ...r }));
            gameState.grid = gameState.originalGrid.map(row => [...row]);
            gameState.movingBlocks = gameState.originalMovingBlocks.map(b => ({ ...b }));
            gameState.inventory = [];
            gameState.delivered = 0;
            gameState.steps = 0;
            gameState.isRunning = false;
            gameState.gameEnded = false;
            gameState.playerDead = false;
            commandHistory = []; // Clear command history on restart
            
            clearHistory();
            addToHistory('Game restarted with same layout!', 'info');
            updateStatus('Task restarted - Write your code!', 'waiting');
            updateStats();
            draw();
        }

        // Draw the game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, GRID_SIZE * CELL_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(GRID_SIZE * CELL_SIZE, i * CELL_SIZE);
                ctx.stroke();
            }
            
            // Draw drop zones
            gameState.dropZones.forEach(drop => {
                ctx.fillStyle = COLORS[drop.color].drop;
                ctx.fillRect(
                    drop.x * CELL_SIZE + 1,
                    drop.y * CELL_SIZE + 1,
                    CELL_SIZE - 2,
                    CELL_SIZE - 2
                );
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = 'bold 16px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    drop.color[0].toUpperCase(),
                    drop.x * CELL_SIZE + CELL_SIZE / 2,
                    drop.y * CELL_SIZE + CELL_SIZE / 2
                );
            });
            
            // Draw danger zones
            gameState.dangerZones.forEach(danger => {
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(
                    danger.x * CELL_SIZE + 1,
                    danger.y * CELL_SIZE + 1,
                    CELL_SIZE - 2,
                    CELL_SIZE - 2
                );
                
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(danger.x * CELL_SIZE + 5, danger.y * CELL_SIZE + 5);
                ctx.lineTo((danger.x + 1) * CELL_SIZE - 5, (danger.y + 1) * CELL_SIZE - 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo((danger.x + 1) * CELL_SIZE - 5, danger.y * CELL_SIZE + 5);
                ctx.lineTo(danger.x * CELL_SIZE + 5, (danger.y + 1) * CELL_SIZE - 5);
                ctx.stroke();
            });
            
            // Draw teleporters
            gameState.teleporters.forEach((teleporter) => {
                const color = teleporter.color === 'purple' ? COLORS.teleporterPurple : COLORS.teleporterOrange;
                const label = teleporter.color === 'purple' ? 'A' : 'B';
                
                teleporter.pair.forEach((pos) => {
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        pos.x * CELL_SIZE + 2,
                        pos.y * CELL_SIZE + 2,
                        CELL_SIZE - 4,
                        CELL_SIZE - 4
                    );
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(
                        pos.x * CELL_SIZE + CELL_SIZE / 2,
                        pos.y * CELL_SIZE + CELL_SIZE / 2,
                        CELL_SIZE / 4,
                        0,
                        Math.PI * 2
                    );
                    ctx.stroke();
                    
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(
                        label,
                        pos.x * CELL_SIZE + CELL_SIZE / 2,
                        pos.y * CELL_SIZE + CELL_SIZE / 2
                    );
                });
            });
            
            // Draw walls
            ctx.fillStyle = '#555';
            gameState.walls.forEach(wall => {
                ctx.fillRect(
                    wall.x * CELL_SIZE + 2,
                    wall.y * CELL_SIZE + 2,
                    CELL_SIZE - 4,
                    CELL_SIZE - 4
                );
            });
            
            // Draw door structure (if not opened)
            if (gameState.doorStructure && !gameState.doorStructure.isOpen) {
                const door = gameState.doorStructure.door;
                // Draw door as a different colored wall
                ctx.fillStyle = '#8b4513'; // Brown color for door
                ctx.fillRect(
                    door.x * CELL_SIZE + 2,
                    door.y * CELL_SIZE + 2,
                    CELL_SIZE - 4,
                    CELL_SIZE - 4
                );
                
                // Draw door handle
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(
                    door.x * CELL_SIZE + CELL_SIZE * 0.75,
                    door.y * CELL_SIZE + CELL_SIZE / 2,
                    4,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Draw lock symbol
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    'LOCKED',
                    door.x * CELL_SIZE + CELL_SIZE / 2,
                    door.y * CELL_SIZE + CELL_SIZE / 2
                );
            }
            
            // Draw resources
            gameState.resources.forEach(resource => {
                if (!resource.collected) {
                    ctx.fillStyle = COLORS[resource.color].resource;
                    ctx.beginPath();
                    ctx.arc(
                        resource.x * CELL_SIZE + CELL_SIZE / 2,
                        resource.y * CELL_SIZE + CELL_SIZE / 2,
                        CELL_SIZE / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    ctx.shadowColor = COLORS[resource.color].resource;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
            
            // Draw moving blocks
            gameState.movingBlocks.forEach(block => {
                ctx.fillStyle = COLORS.movingBlock;
                ctx.fillRect(
                    block.x * CELL_SIZE + 4,
                    block.y * CELL_SIZE + 4,
                    CELL_SIZE - 8,
                    CELL_SIZE - 8
                );
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    ctx.moveTo(block.x * CELL_SIZE + 8 + i * 8, block.y * CELL_SIZE + 8);
                    ctx.lineTo(block.x * CELL_SIZE + 12 + i * 8, block.y * CELL_SIZE + 12);
                    ctx.lineTo(block.x * CELL_SIZE + 8 + i * 8, block.y * CELL_SIZE + 16);
                    ctx.stroke();
                }
                
                ctx.shadowColor = COLORS.movingBlock;
                ctx.shadowBlur = 10;
                ctx.strokeRect(
                    block.x * CELL_SIZE + 4,
                    block.y * CELL_SIZE + 4,
                    CELL_SIZE - 8,
                    CELL_SIZE - 8
                );
                ctx.shadowBlur = 0;
            });
            
            // Draw player
            if (!gameState.playerDead) {
                ctx.fillStyle = '#fff';
                ctx.fillRect(
                    gameState.player.x * CELL_SIZE + 5,
                    gameState.player.y * CELL_SIZE + 5,
                    CELL_SIZE - 10,
                    CELL_SIZE - 10
                );
                
                ctx.shadowColor = '#4ecca3';
                ctx.shadowBlur = 15;
                ctx.fillRect(
                    gameState.player.x * CELL_SIZE + 5,
                    gameState.player.y * CELL_SIZE + 5,
                    CELL_SIZE - 10,
                    CELL_SIZE - 10
                );
                ctx.shadowBlur = 0;
                
                if (gameState.inventory.length > 0) {
                    ctx.fillStyle = COLORS[gameState.inventory[0]].resource;
                    ctx.beginPath();
                    ctx.arc(
                        gameState.player.x * CELL_SIZE + CELL_SIZE / 2,
                        gameState.player.y * CELL_SIZE + CELL_SIZE / 2,
                        6,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        }

        // Move all moving blocks
        function moveMovingBlocks() {
            gameState.movingBlocks.forEach(block => {
                if (gameState.grid[block.y][block.x] === 'moving_block') {
                    gameState.grid[block.y][block.x] = 'empty';
                }
                
                let newX = block.x + block.dx;
                let newY = block.y + block.dy;
                
                let shouldBounce = false;
                
                if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                    shouldBounce = true;
                } else if (gameState.grid[newY][newX] === 'wall' || 
                          gameState.grid[newY][newX] === 'danger' ||
                          gameState.grid[newY][newX].startsWith('teleporter') ||
                          gameState.grid[newY][newX].startsWith('drop_')) {
                    shouldBounce = true;
                }
                
                const otherBlock = gameState.movingBlocks.find(b => 
                    b.id !== block.id && b.x === newX && b.y === newY
                );
                if (otherBlock) {
                    shouldBounce = true;
                }
                
                const resourceAtPos = gameState.resources.find(r => 
                    !r.collected && r.x === newX && r.y === newY
                );
                if (resourceAtPos) {
                    shouldBounce = true;
                }
                
                if (shouldBounce) {
                    block.dx = -block.dx;
                    block.dy = -block.dy;
                    newX = block.x + block.dx;
                    newY = block.y + block.dy;
                    
                    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE ||
                        gameState.grid[newY][newX] === 'wall' || 
                        gameState.grid[newY][newX] === 'danger' ||
                        gameState.grid[newY][newX].startsWith('teleporter') ||
                        gameState.grid[newY][newX].startsWith('drop_') ||
                        gameState.movingBlocks.some(b => b.id !== block.id && b.x === newX && b.y === newY)) {
                        newX = block.x;
                        newY = block.y;
                    }
                }
                
                block.x = newX;
                block.y = newY;
                
                gameState.grid[block.y][block.x] = 'moving_block';
            });
        }

        // Check if player collides with moving blocks
        function checkMovingBlockCollision() {
            const hitBlock = gameState.movingBlocks.find(b => 
                b.x === gameState.player.x && b.y === gameState.player.y
            );
            return hitBlock !== undefined;
        }

        // Check and handle teleporter
        function checkTeleporter() {
            const cellType = gameState.grid[gameState.player.y][gameState.player.x];
            if (cellType.startsWith('teleporter_')) {
                const parts = cellType.split('_');
                const teleporterId = parseInt(parts[1]);
                const teleporter = gameState.teleporters.find(t => t.id === teleporterId);
                
                if (teleporter) {
                    const destination = teleporter.pair.find(p => 
                        p.x !== gameState.player.x || p.y !== gameState.player.y
                    );
                    
                    if (destination) {
                        gameState.player.x = destination.x;
                        gameState.player.y = destination.y;
                        return { teleported: true, message: `Teleported to (${destination.x}, ${destination.y})!` };
                    }
                }
            }
            return { teleported: false };
        }

        // Reverse a command
        function reverseCommand(cmd) {
            const reversed = { ...cmd };
            
            if (cmd.direction && DIRECTION_OPPOSITES[cmd.direction]) {
                reversed.direction = DIRECTION_OPPOSITES[cmd.direction];
            }
            
            // Update the command string
            if (cmd.command === 'movement') {
                reversed.originalLine = `${reversed.direction}${reversed.coefficient > 1 ? ' ' + reversed.coefficient : ''}`;
            } else if (cmd.command === 'bye') {
                let byeCmd = `bye ${reversed.direction}`;
                if (reversed.whileCondition) {
                    byeCmd += ` while ${reversed.whileCondition}`;
                    if (reversed.onPosition) {
                        // Reverse the position when reversing direction
                        const positionOpposites = { 'l': 'r', 'r': 'l', 'a': 'b', 'b': 'a' };
                        const reversedPos = positionOpposites[reversed.onPosition];
                        reversed.onPosition = reversedPos;
                        byeCmd += ` on ${reversedPos}`;
                    }
                }
                reversed.originalLine = byeCmd;
            }
            
            return reversed;
        }

        // Execute a parsed command
        async function executeParsedCommand(cmd, isReversed = false) {
            let result;
            
            switch (cmd.command) {
                case 'movement':
                    let dx = 0, dy = 0;
                    switch (cmd.direction) {
                        case 'up': dy = -1; break;
                        case 'down': dy = 1; break;
                        case 'left': dx = -1; break;
                        case 'right': dx = 1; break;
                    }
                    
                    for (let i = 0; i < cmd.coefficient; i++) {
                        const moveResult = movePlayer(dx, dy);
                        
                        if (moveResult.dead) {
                            return moveResult;
                        }
                        
                        if (!moveResult.success) {
                            if (i === 0) {
                                return moveResult;
                            } else {
                                return { success: true, message: `Moved ${cmd.direction} ${i} time(s), then blocked` };
                            }
                        }
                        
                        moveMovingBlocks();
                        
                        if (checkMovingBlockCollision()) {
                            draw();
                            return {
                                success: false,
                                dead: true,
                                message: `Moved ${cmd.direction} ${i + 1} time(s) - Moving block crushed you! `
                            };
                        }
                        
                        const teleportResult = checkTeleporter();
                        if (teleportResult.teleported) {
                            addToHistory(teleportResult.message, 'success');
                            if (checkMovingBlockCollision()) {
                                return {
                                    success: false,
                                    dead: true,
                                    message: 'Teleported into a moving block! '
                                };
                            }
                        }
                        
                        draw();
                        await sleep(200);
                    }
                    
                    result = { success: true, message: `Moved ${cmd.direction} ${cmd.coefficient} time(s)` };
                    break;
                    
                case 'bye':
                    result = await executeByeCommand(cmd.direction, cmd.whileCondition, cmd.onPosition);
                    break;
                    
                case 'collect':
                    result = collectResource();
                    if (result.success) {
                        moveMovingBlocks();
                        if (checkMovingBlockCollision()) {
                            gameState.playerDead = true;
                            gameState.gameEnded = true;
                            draw();
                            updateStatus('GAME OVER - Crushed by moving block!', 'dead');
                            addToHistory(' You were hit by a moving block!', 'dead');
                            return { success: false, dead: true, message: 'Killed by moving block!' };
                        }
                        const teleportResult = checkTeleporter();
                        if (teleportResult.teleported) {
                            addToHistory(teleportResult.message, 'success');
                        }
                        draw();
                    } else {
                        // Replace failed collect with stop 1
                        addToHistory('  (No resource - treating as stop 1)', 'info');
                        moveMovingBlocks();
                        gameState.steps++;
                        if (checkMovingBlockCollision()) {
                            draw();
                            return {
                                success: false,
                                dead: true,
                                message: 'Stopped (no resource) - Moving block crushed you! '
                            };
                        }
                        draw();
                        await sleep(200);
                        result = { success: true, message: 'No resource to collect - waited 1 turn' };
                    }
                    break;
                    
                case 'drop':
                    result = dropResource();
                    if (result.success) {
                        moveMovingBlocks();
                        if (checkMovingBlockCollision()) {
                            gameState.playerDead = true;
                            gameState.gameEnded = true;
                            draw();
                            updateStatus('GAME OVER - Crushed by moving block!', 'dead');
                            addToHistory(' You were hit by a moving block!', 'dead');
                            return { success: false, dead: true, message: 'Killed by moving block!' };
                        }
                        draw();
                    } else {
                        // Replace failed drop with stop 1
                        addToHistory('  (No matching drop zone - treating as stop 1)', 'info');
                        moveMovingBlocks();
                        gameState.steps++;
                        if (checkMovingBlockCollision()) {
                            draw();
                            return {
                                success: false,
                                dead: true,
                                message: 'Stopped (no drop zone) - Moving block crushed you! '
                            };
                        }
                        draw();
                        await sleep(200);
                        result = { success: true, message: 'Not on delivery zone - waited 1 turn' };
                    }
                    break;
                    
                case 'stop':
                    for (let i = 0; i < cmd.turns; i++) {
                        moveMovingBlocks();
                        gameState.steps++;
                        
                        if (checkMovingBlockCollision()) {
                            draw();
                            return {
                                success: false,
                                dead: true,
                                message: `Stopped for ${i + 1} turn(s) - Moving block crushed you! `
                            };
                        }
                        
                        draw();
                        await sleep(200);
                    }
                    result = { success: true, message: `Stopped for ${cmd.turns} turn(s) - Moving blocks continued!` };
                    break;
                    
                default:
                    result = { success: false, message: `Unknown command type: ${cmd.command}` };
            }
            
            return result;
        }

        // Parse a command line
        function parseCommand(line) {
            const parts = line.split(/\s+/);
            const command = parts[0].toLowerCase();
            
            if (['up', 'down', 'left', 'right'].includes(command)) {
                const coefficient = parts[1] ? parseInt(parts[1]) : 1;
                if (isNaN(coefficient) || coefficient < 1) {
                    return { valid: false, error: `Invalid coefficient: "${parts[1]}"` };
                }
                return {
                    valid: true,
                    command: 'movement',
                    direction: command,
                    coefficient: coefficient,
                    originalLine: line
                };
            } else if (command === 'bye') {
                const direction = parts[1] ? parts[1].toLowerCase() : null;
                if (!direction || !['up', 'down', 'left', 'right'].includes(direction)) {
                    return { valid: false, error: 'bye command requires a valid direction' };
                }
                const validConditions = ['coin', 'portal', 'wall', 'mine', 'zone', 'door'];
                const validPositions = ['l', 'r', 'b', 'a'];
                let whileCondition = null;
                let onPosition = null;
                
                if (parts.length >= 4 && parts[2].toLowerCase() === 'while') {
                    if (validConditions.includes(parts[3].toLowerCase())) {
                        whileCondition = parts[3].toLowerCase();
                        // Check for "on" modifier
                        if (parts.length >= 6 && parts[4].toLowerCase() === 'on' &&
                            validPositions.includes(parts[5].toLowerCase())) {
                            onPosition = parts[5].toLowerCase();
                        }
                    }
                }
                
                return {
                    valid: true,
                    command: 'bye',
                    direction: direction,
                    whileCondition: whileCondition,
                    onPosition: onPosition,
                    originalLine: line
                };
            } else if (command === 'collect') {
                return { valid: true, command: 'collect', originalLine: line };
            } else if (command === 'drop') {
                return { valid: true, command: 'drop', originalLine: line };
            } else if (command === 'rev') {
                return { valid: true, command: 'rev', originalLine: line };
            } else if (command === 'repeat') {
                const count = parts[1] ? parseInt(parts[1]) : 1;
                if (isNaN(count) || count < 1) {
                    return { valid: false, error: `Invalid repeat count: "${parts[1]}"` };
                }
                return { valid: true, command: 'repeat', count: count, originalLine: line };
            } else if (command === 'stop') {
                const turns = parts[1] ? parseInt(parts[1]) : 1;
                if (isNaN(turns) || turns < 1) {
                    return { valid: false, error: `Invalid stop count: "${parts[1]}"` };
                }
                return { valid: true, command: 'stop', turns: turns, originalLine: line };
            } else {
                return { valid: false, error: `Unknown command: "${command}"` };
            }
        }

        // Execute commands
        async function runCommands() {
            if (gameState.isRunning) {
                return;
            }
            
            if (gameState.gameEnded) {
                addToHistory('Game ended. Restart or generate new task to play again.', 'error');
                return;
            }
            
            const input = document.getElementById('commandInput').value.trim();
            if (!input) {
                addToHistory('Please enter commands first!', 'error');
                return;
            }
            
            gameState.isRunning = true;
            commandHistory = []; // Reset command history at start of execution
            updateStatus('Running code...', 'running');
            clearHistory();
            addToHistory('Starting execution...', 'info');
            
            const lines = input.split('\n').map(line => line.trim()).filter(line => line);
            
            for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                const line = lines[lineIndex];
                const parsed = parseCommand(line);
                
                if (!parsed.valid) {
                    addToHistory(`> ${line}`, 'info');
                    addToHistory(parsed.error, 'error');
                    break;
                }
                
                // Handle rev command
                if (parsed.command === 'rev') {
                    addToHistory(`> ${line}`, 'rev');
                    
                    // Check for "repeat n" on same line or next line
                    let repeatCount = 1;
                    const currentParts = line.trim().toLowerCase().split(/\s+/);
                    
                    // Check if "repeat n" is on the same line (e.g., "rev repeat 4")
                    if (currentParts.length >= 3 && currentParts[1] === 'repeat') {
                        const count = parseInt(currentParts[2]);
                        if (!isNaN(count) && count >= 1) {
                            repeatCount = count;
                        }
                    }
                    // Check if next line is "repeat n"
                    else if (lineIndex + 1 < lines.length) {
                        const nextLine = lines[lineIndex + 1].trim().toLowerCase();
                        const nextParts = nextLine.split(/\s+/);
                        if (nextParts[0] === 'repeat' && nextParts[1]) {
                            const count = parseInt(nextParts[1]);
                            if (!isNaN(count) && count >= 1) {
                                repeatCount = count;
                                lineIndex++; // Skip the repeat line
                            }
                        }
                    }
                    
                    if (commandHistory.length === 0) {
                        addToHistory('No commands to reverse!', 'error');
                        continue;
                    }
                    
                    // Get last n commands (or all if fewer)
                    const commandsToReverse = commandHistory.slice(-repeatCount);
                    
                    addToHistory(`Reversing last ${commandsToReverse.length} command(s)...`, 'info');
                    
// Reverse and execute each command
                    for (let i = commandsToReverse.length - 1; i >= 0; i--) {
                        let cmdToExecute = commandsToReverse[i];
                        
                        // Convert drop/collect commands to stop
                        if (cmdToExecute.command === 'drop' || cmdToExecute.command === 'collect') {
                            cmdToExecute = {
                                valid: true,
                                command: 'stop',
                                turns: 1,
                                originalLine: 'stop'
                            };
                        }
                        
                        const reversedCmd = reverseCommand(cmdToExecute);
                        addToHistory(`  [REV] ${reversedCmd.originalLine}`, 'rev');
                        
                        const result = await executeParsedCommand(reversedCmd, true);
                        
if (result.success) {
                            addToHistory(result.message, 'success');
                            // Add to history
                            commandHistory.push(reversedCmd);
                        } else {
                            addToHistory(result.message, result.dead ? 'dead' : 'error');
                            if (result.dead) {
                                gameState.playerDead = true;
                                gameState.gameEnded = true;
                                draw();
                                updateStatus('GAME OVER - You died!', 'dead');
                                gameState.isRunning = false;
                                return;
                            }
                            break;
                        }
                        
                        if (gameState.delivered === gameState.totalResources) {
                            updateStatus(`SUCCESS! All resources delivered in ${gameState.steps} steps!`, 'success');
                            addToHistory(' All resources delivered!', 'success');
                            gameState.gameEnded = true;
                            gameState.isRunning = false;
                            return;
                        }
                        
                        await sleep(250);
                    }
                    
                    continue;
                }
                
                // Handle repeat command
                if (parsed.command === 'repeat') {
                    addToHistory(`> ${line}`, 'info');
                    
                    if (commandHistory.length === 0) {
                        addToHistory('No commands to repeat!', 'error');
                        continue;
                    }
                    
                    const commandsToRepeat = commandHistory.slice(-parsed.count);
                    
                    addToHistory(`Repeating last ${commandsToRepeat.length} command(s)...`, 'info');
                    
                    for (const cmd of commandsToRepeat) {
                        addToHistory(`  [REP] ${cmd.originalLine}`, 'info');
                        
                        const result = await executeParsedCommand(cmd);
                        
if (result.success) {
                            addToHistory(result.message, 'success');
                            commandHistory.push(cmd);
                        } else {
                            addToHistory(result.message, result.dead ? 'dead' : 'error');
                            if (result.dead) {
                                gameState.playerDead = true;
                                gameState.gameEnded = true;
                                draw();
                                updateStatus('GAME OVER - You died!', 'dead');
                                gameState.isRunning = false;
                                return;
                            }
                            break;
                        }
                        
                        if (gameState.delivered === gameState.totalResources) {
                            updateStatus(`SUCCESS! All resources delivered in ${gameState.steps} steps!`, 'success');
                            addToHistory(' All resources delivered!', 'success');
                            gameState.gameEnded = true;
                            gameState.isRunning = false;
                            return;
                        }
                        
                        await sleep(250);
                    }
                    
                    continue;
                }
                
                // Regular command execution
                addToHistory(`> ${line}`, 'info');
                
                const result = await executeParsedCommand(parsed);
                
if (result.success) {
                    addToHistory(result.message, 'success');
                    // Add to command history
                    commandHistory.push(parsed);
                } else {
                    addToHistory(result.message, result.dead ? 'dead' : 'error');
                    if (result.dead) {
                        gameState.playerDead = true;
                        gameState.gameEnded = true;
                        draw();
                        updateStatus('GAME OVER - You died!', 'dead');
                        gameState.isRunning = false;
                        return;
                    }
                    break;
                }
                
                if (gameState.delivered === gameState.totalResources) {
                    updateStatus(`SUCCESS! All resources delivered in ${gameState.steps} steps!`, 'success');
                    addToHistory(' All resources delivered!', 'success');
                    gameState.gameEnded = true;
                    gameState.isRunning = false;
                    return;
                }
                
                await sleep(250);
            }
            
            gameState.isRunning = false;
            
            if (!gameState.gameEnded) {
                if (gameState.delivered < gameState.totalResources) {
                    updateStatus('Code execution complete. Resources remain undelivered!', 'failed');
                    addToHistory('Execution complete. Not all resources delivered.', 'error');
                    gameState.gameEnded = true;
                }
            }
        }

        // Execute bye command
        async function executeByeCommand(direction, whileCondition, onPosition) {
            let dx = 0, dy = 0;
            switch (direction) {
                case 'up': dy = -1; break;
                case 'down': dy = 1; break;
                case 'left': dx = -1; break;
                case 'right': dx = 1; break;
            }
            
            let moveCount = 0;
            
            // Helper to get relative position
            const getRelativePos = (pos) => {
                switch (pos) {
                    case 'l': return { x: gameState.player.x - 1, y: gameState.player.y };
                    case 'r': return { x: gameState.player.x + 1, y: gameState.player.y };
                    case 'b': return { x: gameState.player.x, y: gameState.player.y + 1 };
                    case 'a': return { x: gameState.player.x, y: gameState.player.y - 1 };
                    default: return { x: gameState.player.x, y: gameState.player.y };
                }
            };
            
            while (true) {
                const newX = gameState.player.x + dx;
                const newY = gameState.player.y + dy;
                
                if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                    break;
                }
                
                if (gameState.grid[newY][newX] === 'wall') {
                    break;
                }
                
                if (gameState.grid[newY][newX] === 'danger') {
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                    moveCount++;
                    gameState.steps++;
                    draw();
                    return { 
                        success: false, 
                        dead: true,
                        message: `Moved ${direction} ${moveCount} time(s) and entered a DANGER ZONE! ` 
                    };
                }
                
                if (gameState.grid[newY][newX] === 'moving_block') {
                    gameState.player.x = newX;
                    gameState.player.y = newY;
                    moveCount++;
                    gameState.steps++;
                    draw();
                    return {
                        success: false,
                        dead: true,
                        message: `Moved ${direction} ${moveCount} time(s) and got crushed by a moving block! `
                    };
                }
                
                gameState.player.x = newX;
                gameState.player.y = newY;
                moveCount++;
                gameState.steps++;
                
                moveMovingBlocks();
                
                if (checkMovingBlockCollision()) {
                    draw();
                    return {
                        success: false,
                        dead: true,
                        message: `Moved ${direction} ${moveCount} time(s) - Moving block crushed you! `
                    };
                }
                
                const teleportResult = checkTeleporter();
                if (teleportResult.teleported) {
                    draw();
                    addToHistory(teleportResult.message, 'success');
                    if (checkMovingBlockCollision()) {
                        return {
                            success: false,
                            dead: true,
                            message: 'Teleported into a moving block! '
                        };
                    }
                }
                
                draw();
                
                // Check if player stepped on door
                checkDoor();
                
                await sleep(200);
                
                // Check while conditions
                if (whileCondition) {
                    const checkPos = onPosition ? getRelativePos(onPosition) : 
                                    { x: gameState.player.x, y: gameState.player.y };
                    const checkCell = (checkPos.x >= 0 && checkPos.x < GRID_SIZE && 
                                      checkPos.y >= 0 && checkPos.y < GRID_SIZE) ?
                                      gameState.grid[checkPos.y][checkPos.x] : null;
                    const currentCell = gameState.grid[gameState.player.y][gameState.player.x];
                    let conditionMet = false;
                    let message = '';
                    const positionText = onPosition ? ` on ${onPosition}` : '';
                    
                    switch (whileCondition) {
                        case 'coin':
                            if (onPosition) {
                                const resource = gameState.resources.find(
                                    r => r.x === checkPos.x && r.y === checkPos.y && !r.collected
                                );
                                if (resource) {
                                    conditionMet = true;
                                    message = `Moved ${direction} ${moveCount} time(s) and found a ${resource.color} coin${positionText}!`;
                                }
                            } else {
                                const resource = gameState.resources.find(
                                    r => r.x === gameState.player.x && r.y === gameState.player.y && !r.collected
                                );
                                if (resource) {
                                    conditionMet = true;
                                    message = `Moved ${direction} ${moveCount} time(s) and found a ${resource.color} coin!`;
                                }
                            }
                            break;
                        case 'portal':
                            if (checkCell && checkCell.startsWith('teleporter_')) {
                                conditionMet = true;
                                message = `Moved ${direction} ${moveCount} time(s) and found a portal${positionText}!`;
                            }
                            break;
                        case 'wall':
                            if (checkCell === 'wall') {
                                conditionMet = true;
                                message = `Moved ${direction} ${moveCount} time(s) and found a wall${positionText}!`;
                            }
                            break;
                        case 'mine':
                            if (checkCell === 'danger') {
                                conditionMet = true;
                                message = `Moved ${direction} ${moveCount} time(s) and found a mine${positionText}!`;
                            }
                            break;
                        case 'zone':
                            if (checkCell && checkCell.startsWith('drop_')) {
                                const zoneColor = checkCell.replace('drop_', '');
                                conditionMet = true;
                                message = `Moved ${direction} ${moveCount} time(s) and found a ${zoneColor} drop zone${positionText}!`;
                            }
                            break;
                        case 'door':
                            if (checkCell === 'door') {
                                conditionMet = true;
                                message = `Moved ${direction} ${moveCount} time(s) and found a door${positionText}!`;
                            }
                            break;
                    }
                    
                    if (conditionMet) {
                        return { success: true, message: message };
                    }
                }
            }
            
            if (moveCount === 0) {
                return { success: false, message: `Cannot move ${direction}: Blocked immediately!` };
            }
            
            const positionText = onPosition ? ` on ${onPosition}` : '';
            const condition = whileCondition ? `until blocked (no ${whileCondition}${positionText} found)` : "until blocked";
            return { success: true, message: `Moved ${direction} ${moveCount} time(s) ${condition}` };
        }

        // Move player
        function movePlayer(dx, dy) {
            const newX = gameState.player.x + dx;
            const newY = gameState.player.y + dy;
            
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                return { success: false, message: 'Cannot move: Out of bounds!' };
            }
            
            if (gameState.grid[newY][newX] === 'wall') {
                return { success: false, message: 'Cannot move: Wall in the way!' };
            }
            
            if (gameState.grid[newY][newX] === 'danger') {
                gameState.player.x = newX;
                gameState.player.y = newY;
                return { 
                    success: false, 
                    dead: true,
                    message: 'You entered a DANGER ZONE and died! ' 
                };
            }
            
            if (gameState.grid[newY][newX] === 'moving_block') {
                gameState.player.x = newX;
                gameState.player.y = newY;
                return {
                    success: false,
                    dead: true,
                    message: 'You walked into a moving block and got crushed! '
                };
            }
            
            gameState.player.x = newX;
            gameState.player.y = newY;
            
            // Check if player stepped on door
            checkDoor();
            
            const dir = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'down' : 'up';
            return { success: true, message: `Moved ${dir} to (${newX}, ${newY})` };
        }

        // Collect resource
        function collectResource() {
            if (gameState.inventory.length >= MAX_INVENTORY) {
                return { success: false, message: `Inventory full! Max ${MAX_INVENTORY} items. Deliver some first!` };
            }
            
            const resource = gameState.resources.find(
                r => r.x === gameState.player.x && r.y === gameState.player.y && !r.collected
            );
            
            if (resource) {
                resource.collected = true;
                gameState.inventory.push(resource.color);
                updateStats();
                return { success: true, message: `Collected ${resource.color} resource! (${gameState.inventory.length}/${MAX_INVENTORY})` };
            }
            
            return { success: false, message: 'No resource to collect at current position!' };
        }

        // Drop resource
        function dropResource() {
            const dropZone = gameState.dropZones.find(
                d => d.x === gameState.player.x && d.y === gameState.player.y
            );
            
            if (!dropZone) {
                return { success: false, message: 'Not on a delivery zone! Find a colored base.' };
            }
            
            const matchingResources = gameState.inventory.filter(color => color === dropZone.color);
            
            if (matchingResources.length === 0) {
                return { success: false, message: `No ${dropZone.color} resources to deliver here!` };
            }
            
            let deliveredCount = 0;
            gameState.inventory = gameState.inventory.filter(color => {
                if (color === dropZone.color) {
                    deliveredCount++;
                    gameState.delivered++;
                    
                    const resource = gameState.resources.find(
                        r => r.color === color && r.collected && !r.delivered
                    );
                    if (resource) {
                        resource.delivered = true;
                    }
                    
                    return false;
                }
                return true;
            });
            
            updateStats();
            return { success: true, message: `Delivered ${deliveredCount} ${dropZone.color} resource(s)!` };
        }

        // Utility functions
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function updateStats() {
            document.getElementById('resourceCount').textContent = 
                `${gameState.delivered}/${gameState.totalResources}`;
            document.getElementById('stepCount').textContent = gameState.steps;
            document.getElementById('playerPos').textContent = 
                `${gameState.player.x},${gameState.player.y}`;
            document.getElementById('healthStatus').textContent = 
                gameState.playerDead ? 'DEAD' : 'OK';
            document.getElementById('healthStatus').style.color = 
                gameState.playerDead ? '#ff4444' : '#4ecca3';
            
            document.getElementById('inventoryCount').textContent = 
                `${gameState.inventory.length}/${MAX_INVENTORY}`;
            
            const inventoryItemsEl = document.getElementById('inventoryItems');
            if (gameState.inventory.length === 0) {
                inventoryItemsEl.innerHTML = '<span class="inventory-empty">Empty</span>';
            } else {
                inventoryItemsEl.innerHTML = gameState.inventory.map(color => 
                    `<div class="inventory-item item-${color}"></div>`
                ).join('');
            }
        }

        function updateStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
        }

        function addToHistory(message, type) {
            const historyEl = document.getElementById('commandHistory');
            const line = document.createElement('div');
            line.className = `command-line command-${type}`;
            line.textContent = message;
            historyEl.appendChild(line);
            historyEl.scrollTop = historyEl.scrollHeight;
        }

        function clearHistory() {
            document.getElementById('commandHistory').innerHTML = '';
        }

        function clearConsole() {
            document.getElementById('commandInput').value = '';
            clearHistory();
            addToHistory('Console cleared.', 'info');
        }

        // Check if player is on the door and trigger labyrinth
        function checkDoor() {
            if (!gameState.doorStructure || gameState.doorStructure.labyrinthTriggered || gameState.doorStructure.isOpen) {
                return;
            }
            
            const door = gameState.doorStructure.door;
            if (gameState.player.x === door.x && gameState.player.y === door.y) {
                // Player is on door - trigger labyrinth minigame
                gameState.doorStructure.labyrinthTriggered = true;
                gameState.labyrinthActive = true;
                startLabyrinthMinigame();
            }
        }

        // Generate labyrinth for minigame
        function generateLabyrinth() {
            labyrinthState.grid = [];
            labyrinthState.dangerZones = [];
            
            for (let y = 0; y < LABYRINTH_HEIGHT; y++) {
                labyrinthState.grid[y] = [];
                for (let x = 0; x < LABYRINTH_WIDTH; x++) {
                    labyrinthState.grid[y][x] = 'empty';
                }
            }
            
            // Generate danger walls (about 25% of cells) - red walls that kill you
            const dangerWallCount = Math.floor(LABYRINTH_WIDTH * LABYRINTH_HEIGHT * 0.25);
            let emptyCells = [];
            for (let y = 0; y < LABYRINTH_HEIGHT; y++) {
                for (let x = 0; x < LABYRINTH_WIDTH; x++) {
                    if (x !== 0 || y !== 0) {
                        emptyCells.push({ x, y });
                    }
                }
            }
            
            for (let i = 0; i < dangerWallCount && emptyCells.length > 0; i++) {
                const idx = Math.floor(seededRandom() * emptyCells.length);
                const { x, y } = emptyCells.splice(idx, 1)[0];
                
                labyrinthState.grid[y][x] = 'danger';
                labyrinthState.dangerZones.push({ x, y });
            }
            
            // Place exit at far corner
            labyrinthState.exit = { x: LABYRINTH_WIDTH - 1, y: LABYRINTH_HEIGHT - 1 };
            
            // Ensure exit is not blocked
            if (labyrinthState.grid[LABYRINTH_HEIGHT - 1][LABYRINTH_WIDTH - 1] !== 'empty') {
                labyrinthState.grid[LABYRINTH_HEIGHT - 1][LABYRINTH_WIDTH - 1] = 'empty';
                // Remove from danger if present
                labyrinthState.dangerZones = labyrinthState.dangerZones.filter(d => 
                    !(d.x === LABYRINTH_WIDTH - 1 && d.y === LABYRINTH_HEIGHT - 1));
            }
            
            // Reset player position
            labyrinthState.player = { x: 0, y: 0 };
        }

        // Start labyrinth minigame
        function startLabyrinthMinigame() {
            generateLabyrinth();
            
            // Create or show labyrinth modal
            let modal = document.getElementById('labyrinthModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'labyrinthModal';
                modal.className = 'labyrinth-modal';
                modal.innerHTML = `
                    <div class="labyrinth-container">
                        <h2 class="labyrinth-title">DOOR LOCKED - LABYRINTH CHALLENGE</h2>
                        <canvas id="labyrinthCanvas" class="labyrinth-canvas" width="700" height="420"></canvas>
                        <p class="labyrinth-instructions">Use Arrow Keys or WASD to navigate. ALL RED WALLS KILL YOU! Reach the green exit!</p>
                        <p id="labyrinthStatus" class="labyrinth-status"></p>
                        <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
                            <button onclick="generateNewLabyrinth()" style="background: #e94560; color: white; padding: 10px 20px; border: none; border-radius: 6px; font-family: 'Courier New', monospace; font-weight: bold; cursor: pointer;">New Maze</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            modal.classList.add('active');
            
            // Set up keyboard controls
            document.addEventListener('keydown', handleLabyrinthKey);
            
            drawLabyrinth();
            updateLabyrinthStatus('Navigate to the GREEN exit to unlock the door!');
        }

        // Generate a new labyrinth maze
        function generateNewLabyrinth() {
            generateLabyrinth();
            drawLabyrinth();
            updateLabyrinthStatus('New maze generated! Navigate to the GREEN exit!');
        }

        // Handle labyrinth keyboard input
        function handleLabyrinthKey(e) {
            if (!gameState.labyrinthActive) return;
            
            let dx = 0, dy = 0;
            
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    dy = -1;
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    dy = 1;
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    dx = -1;
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    dx = 1;
                    break;
                default:
                    return;
            }
            
            e.preventDefault();
            moveLabyrinthPlayer(dx, dy);
        }

        // Move player in labyrinth
        function moveLabyrinthPlayer(dx, dy) {
            const newX = labyrinthState.player.x + dx;
            const newY = labyrinthState.player.y + dy;
            
            // Check bounds
            if (newX < 0 || newX >= LABYRINTH_WIDTH || newY < 0 || newY >= LABYRINTH_HEIGHT) {
                return;
            }
            
            // Check danger zone (walls are now red danger zones that kill you)
            if (labyrinthState.grid[newY][newX] === 'danger') {
                updateLabyrinthStatus('You died! Try again...');
                labyrinthState.player = { x: 0, y: 0 }; // Reset to start
                drawLabyrinth();
                return;
            }
            
            // Move player
            labyrinthState.player.x = newX;
            labyrinthState.player.y = newY;
            
            drawLabyrinth();
            
            // Check if reached exit
            if (newX === labyrinthState.exit.x && newY === labyrinthState.exit.y) {
                completeLabyrinth();
            }
        }

        // Complete labyrinth and open door
        function completeLabyrinth() {
            gameState.labyrinthCompleted = true;
            gameState.labyrinthActive = false;
            gameState.doorStructure.isOpen = true;
            
            // Remove door from walls
            const doorIdx = gameState.walls.findIndex(w => 
                w.x === gameState.doorStructure.door.x && 
                w.y === gameState.doorStructure.door.y
            );
            if (doorIdx !== -1) {
                gameState.walls.splice(doorIdx, 1);
            }
            
            // Update grid - mark door as empty
            gameState.grid[gameState.doorStructure.door.y][gameState.doorStructure.door.x] = 'empty';
            
            // Close modal
            const modal = document.getElementById('labyrinthModal');
            if (modal) {
                modal.classList.remove('active');
            }
            
            document.removeEventListener('keydown', handleLabyrinthKey);
            
            // Update game status
            updateStatus('Door unlocked! You can now enter the structure.', 'success');
            addToHistory('Labyrinth completed! Door is now open!', 'success');
            
            draw();
        }

        // Update labyrinth status text
        function updateLabyrinthStatus(message) {
            const statusEl = document.getElementById('labyrinthStatus');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        // Draw the labyrinth
        function drawLabyrinth() {
            const canvas = document.getElementById('labyrinthCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.strokeStyle = '#0f3460';
            ctx.lineWidth = 1;
            for (let i = 0; i <= LABYRINTH_WIDTH; i++) {
                ctx.beginPath();
                ctx.moveTo(i * LABYRINTH_CELL_SIZE, 0);
                ctx.lineTo(i * LABYRINTH_CELL_SIZE, LABYRINTH_HEIGHT * LABYRINTH_CELL_SIZE);
                ctx.stroke();
            }
            for (let i = 0; i <= LABYRINTH_HEIGHT; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * LABYRINTH_CELL_SIZE);
                ctx.lineTo(LABYRINTH_WIDTH * LABYRINTH_CELL_SIZE, i * LABYRINTH_CELL_SIZE);
                ctx.stroke();
            }
            
            // Draw danger zones
            labyrinthState.dangerZones.forEach(danger => {
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(
                    danger.x * LABYRINTH_CELL_SIZE + 1,
                    danger.y * LABYRINTH_CELL_SIZE + 1,
                    LABYRINTH_CELL_SIZE - 2,
                    LABYRINTH_CELL_SIZE - 2
                );
                
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(danger.x * LABYRINTH_CELL_SIZE + 5, danger.y * LABYRINTH_CELL_SIZE + 5);
                ctx.lineTo((danger.x + 1) * LABYRINTH_CELL_SIZE - 5, (danger.y + 1) * LABYRINTH_CELL_SIZE - 5);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo((danger.x + 1) * LABYRINTH_CELL_SIZE - 5, danger.y * LABYRINTH_CELL_SIZE + 5);
                ctx.lineTo(danger.x * LABYRINTH_CELL_SIZE + 5, (danger.y + 1) * LABYRINTH_CELL_SIZE - 5);
                ctx.stroke();
            });
            
            // Draw exit
            ctx.fillStyle = '#4ecca3';
            ctx.fillRect(
                labyrinthState.exit.x * LABYRINTH_CELL_SIZE + 2,
                labyrinthState.exit.y * LABYRINTH_CELL_SIZE + 2,
                LABYRINTH_CELL_SIZE - 4,
                LABYRINTH_CELL_SIZE - 4
            );
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(
                'EXIT',
                labyrinthState.exit.x * LABYRINTH_CELL_SIZE + LABYRINTH_CELL_SIZE / 2,
                labyrinthState.exit.y * LABYRINTH_CELL_SIZE + LABYRINTH_CELL_SIZE / 2
            );
            
            // Draw player
            ctx.fillStyle = '#fff';
            ctx.fillRect(
                labyrinthState.player.x * LABYRINTH_CELL_SIZE + 5,
                labyrinthState.player.y * LABYRINTH_CELL_SIZE + 5,
                LABYRINTH_CELL_SIZE - 10,
                LABYRINTH_CELL_SIZE - 10
            );
            
            ctx.shadowColor = '#4ecca3';
            ctx.shadowBlur = 15;
            ctx.fillRect(
                labyrinthState.player.x * LABYRINTH_CELL_SIZE + 5,
                labyrinthState.player.y * LABYRINTH_CELL_SIZE + 5,
                LABYRINTH_CELL_SIZE - 10,
                LABYRINTH_CELL_SIZE - 10
            );
            ctx.shadowBlur = 0;
        }

        // Initial draw
        initGrid();
        draw();
    </script>
</body>
</html>
